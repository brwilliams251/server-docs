= 組み込みエンドポイント
:pp: {plus}{plus}
:description: TigerGraphサーバーに組み込まれているすべてのREST APIエンドポイント。

== システムユーティリティ

=== Echo

`GET /echo` と `POST /echo`

これらのエンドポイントはシンプルな診断ユーティリティであり、RESTPPサーバーが稼働している場合、以下のメッセージを返します。

==== リクエストサンプル:

.GET echo/ リクエストと応答

[source,console]
----
curl -X GET "http://localhost:9000/echo"
{
    "error": false,
    "message": "Hello GSQL"
}
----



`POST/echo` の応答は `GET/echo` と同じです。

==== パラメーター

|===
| 名称 | 必須 | 説明

| `sleep`
| いいえ
| 応答が遅延する秒数を表す整数。
|===

=== ヘルスチェック(パブリック)

このエンドポイントは、シンプルなサーバーのヘルスチェックを実行します。ポート14240でリッスンし、認証は必要としません。pingを実行し、サーバーが実行されている場合は、"pong"というメッセージで応答します。

==== エンドポイント:

`GET /api/ping`

==== リクエストサンプル:

[source,text]
----
$ curl 'http://localhost:14240/api/ping'
​
{
  "error": "false",
  "message": "pong",
  "results": {}
}
----

==== パラメーター:

パラメーターはありません。

=== すべてのエンドポイントのリスト

`+GET /endpoints/{graph_name}+`

このエンドポイントは、インストールされているエンドポイントとそのパラメーターのリストを返します。エンドポイントには以下の3つのタイプがあります。

* __組み込みエンドポイント__ : TigerGraphシステムにプレインストールされているエンドポイント。
* __動的エンドポイント__ : GSQLクエリーのコンパイル時に生成されるエンドポイント。
* __静的エンドポイント__ : ユーザーがインストールしたエンドポイント。

1つ以上のエンドポイントタイプを出力に含めるには、エンドポイントタイプをパラメータークエリ文字列に含め、値を `true` に設定します。タイプパラメーターを指定しない場合、すべてのエンドポイントが返されます。

.例: すべての組み込みエンドポイントのレポート

[source,console]
----
curl -X GET "http://localhost:9000/endpoints?builtin=true" | jq .
----



==== 応答

組み込みのエンドポイントは10以上あり、その中の一部は複数のパラメーターを持つため、すべての組み込みエンドポイントのフォーマットされたJSON出力は300行を超えます。完全なリストは、付録Aでご覧ください。以下は出力の抜粋です。

.GETのサブセット / エンドポイントの出力

[source,console]
----
    "GET /endpoints": {
        "parameters": {
            "builtin": {
                "default": "false",
                "max_count": 1,
                "min_count": 0,
                "type": "BOOL"
            },
            "dynamic": {
                "default": "false",
                "max_count": 1,
                "min_count": 0,
                "type": "BOOL"
            },
            "static": {
                "default": "false",
                "max_count": 1,
                "min_count": 0,
                "type": "BOOL"
            }
        }
    }
----



==== パラメーター

|===
| 名称 | 必須 | 説明

| `builtin`
| いいえ
| ブール値を取ります。 `true` の場合、組み込みのエンドポイントを返します。

| `dynamic`
| いいえ
| ブール値を取ります。 `true` の場合、動的エンドポイントを返します。

| `static`
| いいえ
| ブール値を取ります。 `true` の場合、ユーザーがインストールしたエンドポイントを返します。
|===

=== コンポーネントのバージョンの表示

`GET /version`

このエンドポイントは、システムのすべてのコンポーネントのGITバージョンを返します。

==== リクエストサンプル:

[source,console]
----
curl -X GET "http://localhost:9000/version"
{"error":"false", "message":"TigerGraph RESTPP:
 --- Version ---
product              release_2.6.0_05-09-2020 ab1e3d0da6237c27468d6cabb90900119d63759d  2020-04-15 15:46:29 -0700
olgp                 release_2.6.0_05-09-2020 046c745088106b69920b9bdb3bd15969de409e92  2020-05-01 19:10:27 -0700
topology             release_2.6.0_05-09-2020 c028af100117f2051b619436c3aa4febc810bf36  2020-04-22 08:44:07 -0700
gpe                  release_2.6.0_05-09-2020 34b9e86ef7b5fdaa106637e7db1d8a9e080a0aa2  2020-04-19 09:42:59 -0700
gse                  release_2.6.0_05-09-2020 ed2c2351357aa9077fa4dee7ea7a01f8ad2f7585  2020-05-11 01:18:54 -0700
third_party          release_2.6.0_05-09-2020 4bce6990bae5be2b91e9201693ceb66341d3f204  2020-04-19 09:42:56 -0700
utility              release_2.6.0_05-09-2020 2ce197d3edb3557bdd66ed1a4194309908d6197e  2020-04-20 21:19:34 -0700
realtime             release_2.6.0_05-09-2020 52a82b454437c73b47d846acd5803ab0d9f54a45  2020-04-22 08:44:11 -0700
er                   release_2.6.0_05-09-2020 a3e6cb7606fb74984c75cae9bbd4d2112fdbf73a  2020-05-01 19:10:33 -0700
gle                  release_2.6.0_05-09-2020 d8bdbd1cf346e181aa9a317c704dd7b3b11b4658  2020-05-06 00:51:04 -0700
bigtest              release_2.6.0_05-09-2020 2f64c47b7a5ac1834ead9a22eef8d42241117853  2019-12-12 01:31:35 -0800
document             release_2.6.0_05-09-2020 6327094bd76b2dbc8f4625108d547827344b5091  2019-12-13 16:30:13 -0800
glive                release_2.6.0_05-09-2020 93f61ea06fe42759c808fc58ff6245c9954d5447  2020-02-05 22:40:24 -0800
gap                  release_2.6.0_05-09-2020 e798efb595545bf91c449034566857c41f52449a  2020-04-29 22:47:26 -0700
gst                  release_2.6.0_05-09-2020 1b695c02f277efad0ddfb2deab710ae0158409da  2020-04-29 22:47:32 -0700
gus                  release_2.6.0_05-09-2020 eee784502b5387844e462305bae419954784da6f  2020-04-29 22:47:20 -0700
blue_features        release_2.6.0_05-09-2020 5d7a4e8d806519f529274b331496d3bc78f01990  2020-04-15 15:46:38 -0700
blue_commons         release_2.6.0_05-09-2020 432763afc49bf986aed4731e50254243d3665bc3  2019-07-30 03:34:46 -0700
"}
----

==== パラメーター

このエンドポイントはパラメーターを取りません。

=== システムメトリックのモニター

`POST /ts3/api/datapoints`

TigerGraph System State Service(TS3)は、システムメトリックおよびイベント収集を行うTigerGraphのマネージドモニタリングサービスです。多くのTigerGraphコンポーネントは、CPU使用率、メモリー使用率、ディスク使用率、ネットワークトラフィックなどのメトリックをTS3に定期的にレポートします。このエンドポイントを使用して、時間(`when` 、`from` 、 `to` )、コンポーネント( `who` )、メトリック( `what` )、ロケーション( `where` )でフィルタリングして、必要なデータポイントをTS3から読み込みます。このようなメトリックをビジュアルでの確認には、管理ポータル - ダッシュボード - xref:3.2@gui:admin-portal:dashboard.adoc[クラスターのモニタリング]で行うことができます。

TigerGraphクラスターでは、このエンドポイントは `m1` ノードにのみ存在します。

==== パラメーター
[width="100%",cols="12%,10%,78%",options="header",]
|===
|名称 |必須 |説明
|`+from+` |いいえ |タイムフィルター開始を示すエポックタイムスタンプ。
タイムスタンプの後にレポートされたデータポイントのみが
結果に含まれます。

|`+to+` |いいえ |タイムフィルター開始を示すエポックタイムスタンプ。
タイムスタンプの前にレポートされたデータポイントのみが
結果に含まれます。

|`+latest+` |いいえ |返される最新のデータポイント数。提供された場合、
エンドポイントは、 `+what+` 、 `+who+` 、および `+where+` フィルターを
満たす最新のデータポイントを返し、他の時間関連フィルターは
無視されます。

|`+what+` |いいえ |フィルターするメトリック名。可能な値は以下の通りです。

* `+cpu+`: コンポーネントによるCPU使用パーセンテージ
* `+mem+`: コンポーネントによるメモリー使用量(MB)
* `+diskspace+`: ディクショナリーによるディスク
使用量(MB)
* `+network+`: サービス開始以降のネットワーク
トラフィック(byte)
* `+qps+`: エンドポイントによる毎秒の
リクエスト数
*  `+servicestate+`: サービスがオンラインであるかどうか。 `+0+` の場合はオフライン、`+1+` の場合はオンライン。`+connection+` はTCP接続の数を示します。

|`+who+` |いいえ |データポイントをレポートしたコンポーネントの名前

|`+where+` |いいえ |データポイントがレポートされるノードの名前
|===

==== リクエストサンプル:

以下のリクエストサンプルでは、クエリー文字列のフィルターに、 `1618957536` で始まり `1619023346` で終わるタイムフレームが含まれ、応答にはCPU情報のみを含めるように指定しています。

[source,console]
----
$ curl -X GET
"https://crunch.i.tgcloud.io:14240/ts3/api/datapoints?from=1618957536&to=1619023346&what=cpu"

# 3つのデータポイントが返されました
[
  {
    "detail": 0,  # GPE is using 0 percent CPU
    "when": 1619023346,
    "where": "m1",
    "who": "GPE_1#1",
    "what": "cpu"
  },
  {
    "detail": 0,
    "when": 1619023346,
    "where": "m1",
    "who": "GSE_1#1",
    "what": "cpu"
  },
  {
    "detail": 0,
    "when": 1619023346,
    "where": "m1",
    "who": "RESTPP#1",
    "what": "cpu"
  }
]
----

以下の例では、リクエストはメモリー使用量に関する最新10個のデータポイントを要求しています。

[source,console]
----
$ curl -X GET
"https://crunch.i.tgcloud.io:14240/ts3/api/datapoints?what=mem&latest=10"

[
  {
    "detail": 159,
    "when": 1620076473,
    "where": "m1",
    "who": "RESTPP#1",
    "what": "mem"
  },
  {
    "detail": 211,
    "when": 1620076533,
    "where": "m1",
    "who": "GPE_1#1",
    "what": "mem"
  },
  {
    "detail": 436,
    "when": 1620076533,
    "where": "m1",
    "who": "GSE_1#1",
    "what": "mem"
  },
  {
    "detail": 159,
    "when": 1620076533,
    "where": "m1",
    "who": "RESTPP#1",
    "what": "mem"
  },
  {
    "detail": 211,
    "when": 1620076593,
    "where": "m1",
    "who": "GPE_1#1",
    "what": "mem"
  },
  {
    "detail": 436,
    "when": 1620076593,
    "where": "m1",
    "who": "GSE_1#1",
    "what": "mem"
  },
  {
    "detail": 159,
    "when": 1620076593,
    "where": "m1",
    "who": "RESTPP#1",
    "what": "mem"
  },
  {
    "detail": 210,
    "when": 1620076653,
    "where": "m1",
    "who": "GPE_1#1",
    "what": "mem"
  },
  {
    "detail": 436,
    "when": 1620076653,
    "where": "m1",
    "who": "GSE_1#1",
    "what": "mem"
  },
  {
    "detail": 159,
    "when": 1620076653,
    "where": "m1",
    "who": "RESTPP#1",
    "what": "mem"
  }
]
----

=== クエリーパフォーマンスの表示

`+GET /statistics/{graph_name}+`

このエンドポイントは、 `seconds` パラメーターで指定されているように、指定された期間のリアルタイムのクエリーパフォーマンス統計値を返します。 `seconds` パラメーターは、60以下の正の整数である必要があります。

==== リクエストサンプル:

リターンオブジェクトは、エンドポイントとそのパフォーマンスデータのハッシュ値です。

[source,console]
----
# この例では、過去60秒間に呼び出された2つのエンドポイント
# (/graph/vertexと/statistics)を示しています。
curl -X GET "http://localhost:9000/statistics/poc_graph?seconds=60" | jq '.'

{
  "GET /graph/vertices/{vertex_type}/{vertex_id}": {
    "CompletedRequests": 8,
    "QPS": 0.08,
    "TimeoutRequests": 0,
    "AverageLatency": 130,
    "MaxLatency": 133,
    "MinLatency": 128,
    "LatencyPercentile": [
      200,
      200,
      200,
      200,
      200,
      200,
      200,
      200,
      200,
      200
    ]
  },
  "GET /statistics": {
    "CompletedRequests": 4226,
    "QPS": 42.26,
    "TimeoutRequests": 0,
    "AverageLatency": 2,
    "MaxLatency": 125,
    "MinLatency": 0,
    "LatencyPercentile": [
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      200
    ]
  }
}
----

エンドポイントはそれぞれ以下の属性を持ちます。

* `CompletedRequests` - 完了したリクエスト数。
* `QPS` - 1秒ごとのクエリー数。
* `TimeoutRequests` - システム設定されたタイムアウト制限の前に返されないリクエストの数。タイムアウトリクエストはQPSの計算には含まれません。
* `AverageLatency` - 完了したリクエストの平均レイテンシー。
* `MaxLatency` - 完了したリクエストの最大レイテンシー。
* `MinLatency` - 完了したリクエストの最小レイテンシー。
* `LatencyPercentile` - レイテンシーの分布。この配列の要素数は、このエンドポイントの `segments` パラメーターによって異なり、デフォルト値は10です。つまり、パーセンタイルの範囲0～100%は、0%～10%、11%～20%…の10個の等しいセグメントに分割され、 `segments` は [1, 100]となる必要があります。

過去の指定された秒数に送信されたクエリーがない場合、空のJSONが返されます。

==== パラメーター

|===
| 名称 | 必須 | 説明

| `seconds`
| はい
| 統計レポートがカバーする現在の時刻から何秒前に戻ったかを示す60未満の正の整数。

| `segments`
| いいえ
| 応答の `LatencyPercentile` 配列が分割されるセグメントの数を示す整数。このエンドポイントの値は1〜100である必要があります。デフォルト値は10です。
|===

[#_show_service_status]
=== サービスステータスの表示
`POST :14240/current-service-status`

このエンドポイントは、リクエストで指定されたTigerGraphサービスのステータスを返します。

==== パラメーター
URLパラメーターはありません。

==== リクエスト本文
エンドポイントでは、以下の形式のリクエストの本文が必要です。

[source,javascript]
----
{
    "ServiceDescriptors": [ <1>
        {
            "ServiceName": <service_name>, <2>
            "Partition": <partition_number>, <3>
            "Replica": <replica_number> <4>
        }
        ... <5>
    ]
}
----
<1> `ServiceDescriptors` は必須項目です。
これは、`ServiceName` をキーとし、オプションで `Partition` と `Replica` を持つオブジェクトのリストです。
<2> 必須フィールドです。
ステータスを返すサービスの名前です。
以下は、このフィールドに指定できる値と、それに対応するサービス名です。
* `"GPE"`:     GPE
* `"GSE"`:     GSE
* `"RESTPP"`:  RESTPP
* `"GSQL"`:    GSQL
* `"IFM"`:     INFORMANT
* `"GUI"`:     GUI
* `"CTRL"`:    CONTROLLER
* `"KAFKA"`:   KAFKA
* `"ETCD"`:    ETCD
* `"ZK"`:      ZOOKEEPER
* `"NGINX"`:   NGINX
* `"TS3"`:     TS3
* `"TS3SERV"`: TS3SERV
* `"DICT"`:    DICT
* `"ADMIN"`:   ADMIN
<3> 任意項目です。
サービスステータスを要求するパーティションの番号。
提供されない場合、応答はすべてのパーティションのサービスステータスを含む。
<4> 任意項目です。
サービスステータスを要求するレプリカの番号です。
指定しない場合、すべてのレプリカのサービス状況が応答されます。
<5> 複数のサービスディスクリプタを指定できます。
エンドポイントからの応答には、要求されたすべてのサービスステータスが含まれます。

==== 戻り値
戻り値には、リクエストに含まれる各サービスディスクリプタのステータスが含まれます。
最も重要な情報は `ServiceStatus` フィールドと `ProcessState` フィールドにあります。
[source,javascript]
----
{
  "ServiceStatusEvents": [
    {
      "EventMeta": {
        "Targets": [
          {
            "ServiceName": "IFM"
          }
        ],
        "EventId": "154e8f53716b403eb02af19d863745c6",
        "SpanId": "ServiceStatusSelfReport",
        "TimestampNS": "1635841759229416893",
        "Source": {
          "ServiceName": "GPE",
          "Replica": 1,
          "Partition": 2
        }
      },
      "ServiceDescriptor": { <1>
        "ServiceName": "GPE",
        "Replica": 1,
        "Partition": 2
      },
      "ServiceStatus": "Online", <2>
      "ProcessState": "Running" <3>
    }
  ]
}
----
<1> 返されるステータスのサービス説明。
<2> 最後に記録されたサービスの状態。
<3> サービスの背後にあるLinuxプロセスの最後に記録された状態。
プロセスが動作していても、サービスが提供されておらず、サービスがリクエストに応答できないこともありえます。
例えば、TigerGraphが起動しているとき、GPEは "Warmup" 状態であり、リクエストに応答できませんが、プロセスはまだ実行されています。


==== 例
[tabs]
====
リクエスト::
+
--
[source.wrap,console]
----
$ curl -X POST http://localhost:14240/informant/current-service-status -d '{ "ServiceDescriptors":  [{ "ServiceName": "gpe","Partition": 2, "Replica": 1}]}' | jq
----
--
応答::
+
--
[source,json]
----
{
  "ServiceStatusEvents": [
    {
      "EventMeta": {
        "Targets": [
          {
            "ServiceName": "IFM"
          }
        ],
        "EventId": "154e8f53716b403eb02af19d863745c6",
        "SpanId": "ServiceStatusSelfReport",
        "TimestampNS": "1635841759229416893",
        "Source": {
          "ServiceName": "GPE",
          "Replica": 1,
          "Partition": 2
        }
      },
      "ServiceDescriptor": {
        "ServiceName": "GPE",
        "Replica": 1,
        "Partition": 2
      },
      "ServiceStatus": "Online",
      "ProcessState": "Running"
    }
  ]
}
----
--
====

=== グラフエンジンの再構築

`+GET /rebuildnow/{graph_name}+` or `+POST /rebuildnow/{graph_name}+`

TigerGraphでは、新しいデータ(新しい頂点やエッジなど)がグラフに読み込まれると、データはまずメモリーに保存されてから、ディスクに永続的に保存されます。TigerGraphは、グラフ処理エンジン(Graph Processing Engine: GPE)の再構築を実行し、メモリー内のデータを30秒ごとにディスクにコミットしますが、このエンドポイントを呼び出して、直ちに再構築をトリガーすることも可能です。

==== パラメーター

[width="100%",cols="15%,10%,75%",options="header",]
|===
|名称 |必須 |説明
|`+threadnum+` |いいえ |再構築を実行するために使用するスレッド数。
指定しない場合、TigerGraphを実行しているサーバーのホームディレクトリー内の
`+.tg.cfg+` file (`+"RebuildThreadNumber"+`)の185行目で指定された数が
使用されます。デフォルトは3に設定されています。
このパラメーターの最大値は、分散システムのノード当たりのvCPUの数です。
シングルノードサーバーの場合、最大値はそのノード上のvCPUの数です。
Linuxサーバーのコマンドラインで `+lscpu+` を実行し、
c`+CPU(s)+` 列を調べることで、
vCPUの数の確認ができます。

|`+vertextype+` |いいえ |再構築を実行する頂点タイプ。指定しない場合、再構築はすべての頂点タイプに対して行なわれます。

|`+segid+` |いいえ |再構築するセグメントのセグメントID。指定しない場合、すべてのセグメントが再構築されます。通常、このパラメーターは指定せずに、すべてのセグメントを再構築することが推奨されます。

|`+path+` |いいえ |再構築のサマリーを保存するパス。指定しない場合のデフォルトのパスは `+/tmp/rebuildnow+` です。

|`+force+` |いいえ |新しいデータのレコードがないセグメントに対して再構築を実行するかどうかを指示するブール値。通常、再構築ではこうしたセグメントをスキップしますが、 `+force+` がtrueに設定されていると、
セグメントはスキップされません。
|===

==== 例

[source,console]
----
$ curl -X GET 'http://localhost:9000/rebuildnow/social'

# JSONの応答
{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "RebuildNow finished, please check details in the folder: /tmp/rebuildnow",
  "results": [],
  "code": "REST-0000"
}

# 概要ファイル例
$ cat finished.summary.txt

[SELECTED]	Segment id: 106, vertextype: 0, vertexsubtypeid: 0, vertexcount: 187732, edgecount: 563196, deletevertexcount: 0, postqueue_pos: 16344, transaction id: 16344, rebuild ts: 1573106412990
[SKIPPED]	Segment id: 6, vertextype: 0, vertexsubtypeid: 0, vertexcount: 85732, edgecount: 3106, deletevertexcount: 0, postqueue_pos: 16344, transaction id: 16344, rebuild ts: 1573106412900
----

=== 削除された頂点のチェック

[.line-through]#`GET /deleted_vertex_check`#

まれなことですが、TigerGraphのグラフ処理エンジン(Graph Processing Engine: GPE)とグラフストレージエンジン(Graph Storage Engine: GSE)の頂点削除情報が同期されていない場合があります。これが発生すると、一部の頂点がコンポーネントの1つに存在するにも関わらず、他のコンポーネントには存在しないということが起こる可能性があります。こうしたエラーは非常にまれですが、TigerGraphでは、GSEおよびGPEで削除された頂点をチェックし、同期していない部分がないかどうかを確認できるエンドポイントを提供しています。

削除された頂点について、GSEとGPEの間に不一致がなければ、チェックは合格です。不一致がある場合、チェックは失敗となり、正しく同期されていなかった、削除された頂点のIDが結果として返されます。分散クラスターでTigerGraphを実行している場合、チェックはクラスターの各ノードで実行されます。エンドポイントはすべてのノードのチェック結果のリストを返します。

==== パラメーター
[width="100%",cols="15%,10%,75%",options="header",]
|===
|名称 |必須 |説明
|`threadnum` |いいえ |削除された頂点チェックジョブを実行するために
使用するスレッド数を示す整数。このパラメーターはオプションです。
指定されない場合のデフォルト値は6です。

|`segid` |いいえ |削除された頂点チェックを実行するセグメントのID。
指定されない場合、すべてのセグメントがチェックされます。

|`vertextype` |いいえ |削除された頂点チェックを行なう頂点タイプ。
指定されない場合、チェックはすべての頂点タイプで実行されます。

|`verbose` |いいえ |返される結果の詳細レベルを示す整数。
受け入れ可能な値とそれに対応するレベルは次のとおりです。
`0` (デフォルト) : チェックに合格したかどうかと、
同期されていない頂点IDのリストを返します。 
`1` : レベル0に加えて、頂点カウント情報も返します。
`2` : レベル1に加えて、すべてのセグメントの頂点カウント情報を返します。 
`4` : レベル2に加えて、すべてのセグメントの削除された頂点のIDを
返します。

|`log` |いいえ |削除された頂点チェックのログレベルを示す整数。
このログはエンドポイントのHTTP応答では返されませんが、
`/tigergraph/log/gpe/log.INFO` のGPEコンポーネントのログに出力されます。
`0` (デフォルト): チェックの全体的な簡単なログをレポートします。 
`1` : 各セグメントのログをレポートします。 `2` : 取得した削除済みID
リストの追加のログをレポートします。
|===

==== 例:

[source,bash]
----
# シングルノードデータベースで実行された合格チェック
$ curl -X GET "http://localhost:9000/deleted_vertex_check?threadnum=10&verbose=0" |jq .

{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "check passed",
  "results": [
    {
      "GPE": "GPE_1_1",
      "PassCheck": true,
      "UnSyncList": []
    }
  ],
  "code": "REST-0000"
}

# 分散クラスターで実行された失敗チェック

$ curl -X GET 'http://localhost:9000/deleted_vertex_check?threadnum=10&verbose=0&vertextype=region' |jq .
{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "check failed",
  "results": [
    {
      "GPE": "GPE_2_1",
      "PassCheck": false,
      "UnSyncList": [
        {
          "Segid": 193,
          "IsRemote": false,
          "VertexType": "region",
          "GPEDelHash": 7013042118817697000,
          "IDSDelHash": 202375168
        }
      ]
    },
    {
      "GPE": "GPE_3_1",
      "PassCheck": false,
      "UnSyncList": [
        {
          "Segid": 193,
          "IsRemote": true,
          "VertexType": "region",
          "GPEDelHash": 7013042118817697000,
          "IDSDelHash": 202375168
        }
      ]
    },
    {
      "GPE": "GPE_1_1",
      "PassCheck": false,
      "UnSyncList": [
        {
          "Segid": 193,
          "IsRemote": true,
          "VertexType": "region",
          "GPEDelHash": 7013042118817697000,
          "IDSDelHash": 202375168
        }
      ]
    }
  ],
  "code": "REST-0000"
}
----

== 認証

このサブセクションのエンドポイントを使用すると、REST{pp}サーバーに対して行われたリクエストの認証トークンの作成、更新、削除ができます。**これらのエンドポイントは、RESTPPエンドポイントで xref:user-access:enabling-user-authentication.adoc[ユーザー認証が有効になっている]場合のみ存在します。**

=== トークンのリクエスト (`GET`)

`GET /requesttoken`

RESTPPエンドポイントで認証が有効になっている場合、RESTPPサーバーに送信されるすべてのリクエストのリクエストヘッダーにトークンが含まれる必要があります。次のいずれかを使用してトークンを生成できます。

* シークレット: GSQLで生成されたランダムな文字列(xref:user-access:managing-credentials.adoc[ユーザー権限と認証の管理]を参照)
* リクエストヘッダーのユーザー名とパスワード、グラフの指定

==== リクエストサンプル:

[source,bash]
----
curl -X GET "http://localhost:9000/requesttoken?secret=jiokmfqqfu2f95qs6ug85o89rpkneib3&lifetime=1000000"
{
  "code": "REST-0000",
  "expiration": 1616042814,
  "error": false,
  "message": "Generate new token successfully.",
  "token": "tohvf6khjqju8jf0r0l1cohhlm8gi5fq"
}

curl --user example_username:example_password -X GET "localhost:9000/requesttoken?graph=example_graph"
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `secret`
| はい(`graph` が指定されていない場合)
| トークンを生成するためのユーザーのシークレット。

| `lifetime`
| いいえ
| トークンの有効期間(秒)。デフォルト値は約260万(約1カ月)です。

| `graph`
| はい(`secret` が指定されていない場合)
| トークンが有効になるグラフの名前。
|===

`secret` またはユーザー名とパスワードのいずれかを使用してトークンを生成できます。シークレットを提供せず、ユーザー名とパスワードを使用することを選択した場合は、パラメーター `graph` が必須になります。

=== トークンのリクエスト (`POST`)

`POST /requesttoken`

`POST` リクエストを使ってトークンを生成することもできます。これによって、クエリー文字列でシークレットが公開されてしまうことを回避できます。

==== リクエストサンプル:

[source,bash]
----
curl -d <path_to_secret> -X POST \
"http://localhost:9000/requesttoken?lifetime=1000000"
{
  "code": "REST-0000",
  "expiration": 0,
  "error": false,
  "message": "Refresh token successfully.",
  "token": "tohvf6khjqju8jf0r0l1cohhlm8gi5fq"
}
----

`path_to_secret` を、シークレットを含むファイルへのパスに置き換えてください。ファイルには、1行のシークレットのみを含める必要があります。

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `lifetime`
| いいえ
| トークンの有効期間(秒)。デフォルト値は約260万(約1カ月)です。
|===

=== トークンのリフレッシュ

`PUT /requesttoken`

このエンドポイントは、トークンとそれに関するシークレットを取得し、トークンの有効期間をリフレッシュします。トークンそのものは変更されません。

*パラメーター:*

|===
| **名称** | 必須 | 説明

| `token`
| はい
| リフレッシュするトークン。

| `secret`
| はい
| トークンを生成するために使用されるユーザーのシークレット。

| `lifetime`
| はい
| トークンの有効期間(秒)。
|===

==== リクエストサンプル

[source,bash]
----
curl -X PUT "http://localhost:9000/requesttoken?lifetime=15&secret=ksdoilrvpl0r0tef3d4abbpgu0t2u5la&token=0mq98l9pderkaivndf820gudg923p3l0"|jq .
{
  "code": "REST-0000",
  "expiration": 15,
  "error": false,
  "message": "Refresh token successfully.",
  "token": "0mq98l9pderkaivndf820gudg923p3l0"
}
----

[CAUTION]
====
**既知のバグ**: 出力には、有効期限ではなく有効期間が表示されます。
====

=== トークンの削除

`DELETE /requesttoken`

このエンドポイントは、トークンとそれに関するシークレットを取得し、トークンを削除します。

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `token`
| はい
| 削除するトークン。

| `secret`
| はい
| トークンを生成するために使用されるユーザーのシークレット。
|===

== 読み込みジョブ

=== 読み込みジョブの実行

`+POST /ddl/{graph_name}+`

このエンドポイントは、データをグラフに読み込むためのものです。データをHTTPリクエストペイロードとして送信し、DDLローダーによってグラフにロードします。データペイロードは、汎用CSVまたはJSONとしてフォーマット可能です。これについての詳細は、xref:3.2@gsql-ref:ddl-and-loading:system-and-language-basics.adoc[GSQL言語リファレンス Part 1 - グラフの定義とデータのロード]を参照してください。

読み込みジョブが複数のファイルを参照する場合、これを完了するには、複数のHTTPリクエストが必要です。これは、ファイル名変数のデータを、一度に1つしか提供できないためです。読み込みジョブは、リクエストでデータを提供していないファイル名変数を参照する `LOAD` ステートメントをスキップします。ファイル名変数のデータを提供するには、データをリクエスト本文に入れ、 `filename` パラメーター(以下のパラメーター表で説明しています)を使用して、読み込みジョブで定義された変数名と一致させてください。

==== リクエスト本文:

リクエストの本文は、読み込まれるデータです(CSV形式またはJSON形式)。

Curlによって、@記号を使用して入力ファイルからデータを読み取ることができます。

`curl -X POST --data-binary @./company.csv "http://…"`

==== リクエストサンプル:

この例では、読み込みジョブは3つのファイル名変数( `f1` と `f3` )と1つのファイルパス文字列に依存しています。そのため、読み込みジョブを完了するには、3つのHTTP要求が必要です。

[source,bash]
----
# ジョブの読み込み
CREATE LOADING JOB load_data for GRAPH poc_graph {

    DEFINE FILENAME f1;
    DEFINE FILENAME f3;

    LOAD f1 to VERTEX person VALUES ($0, $0);
    LOAD "/home/data/company.csv" to VERTEX company VALUES ($0, $0);

    LOAD f3 to EDGE work_at VALUES ($0, $1, $3, $4, $5);
}

# 2番目のLOADステートメントのためのデータを供給
curl -X POST --data-binary @./another_company.csv \
"http://localhost:9000/ddl/poc_graph?tag=load_data&filename=__GSQL_FILENAME_0__" | jq

{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "sourceFileName": "Online_POST",
      "statistics": {
        "validLine": 7927,
        "rejectLine": 0,
        "failedConditionLine": 0,
        "notEnoughToken": 0,
        "invalidJson": 0,
        "oversizeToken": 0,
        "vertex": [
          {
            "typeName": "company",
            "validObject": 7,
            "noIdFound": 0,
            "invalidAttribute": 0,
            "invalidPrimaryId": 0,
            "invalidSecondaryId": 0,
            "incorrectFixedBinaryLength": 0
          }
        ],
        "edge": [],
        "deleteVertex": [],
        "deleteEdge": []
      }
    }
  ],
  "code": "REST-0000"
}

# 1番目のLOADステートメントのためのファイル名1のデータを供給
curl -X POST --data-binary @./person.csv \
"http://localhost:9000/ddl/poc_graph?tag=load_data&filename=f1"

# 3番目のLOADステートメントのためのファイル名3のデータを供給
curl -X POST --data-binary @./work_at.csv \
"http://localhost:9000/ddl/poc_graph?tag=load_data&filename=f3"
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `tag`
| はい
| DDL読み込みジョブで定義された読み込みジョブ名。

| `filename`
| はい
| データを含むファイルのファイル変数名またはファイルパス。

| `sep`
| いいえ
| CSVデータのセパレーター。データがJSONの場合、このパラメーターを指定する必要はありません。デフォルトのセパレーターはコンマ ``","`` です。

| `eol`
| いいえ
| 行末文字。1文字または2文字のみが許可されます。(特殊なケース、"\r\n"を除きます。)デフォルト値は `"\n"` です。

| `ack`
| いいえ
| `"all"` : すべてのGPEインスタンスが `POST` リクエストを認識した後にリクエストが返されます。`" none "` : RESTPPが `POST` リクエストを処理した直後にリクエストが返されます。

| `timeout`
| いいえ
| タイムアウトの秒数。0が設定されている場合は、システム全体のエンドポイントタイムアウト設定を使用します。

| `concise`
| いいえ
| データ読み込みリクエストの簡潔な結果を返すかどうかを示すブール値。簡潔な結果には、追加または削除された頂点とエッジの数のみが含まれます。デフォルトの応答にある有効な行と無効な行の数などの情報は通知されません。
|===

パラメーター値に特殊文字が含まれている場合、特殊文字は https://www.w3schools.com/tags/ref_urlencode.asp[URL エンコード]を使用する必要があります。バックスラッシュを1つ使うか2つ使うかについての混乱を避けるために、 `eol` または `sep` パラメーターのバックスラッシュエスケープはサポートされていません。

このエンドポイントによってアップロードできるデータの最大サイズは、xref:API:intro.adoc#_request_body_size[ `Nginx.ClientMaxBodySize` ]設定パラメーター(デフォルトは200MB)によって制御されます。

== グラフ

=== グラフの組み込み関数の実行

`+POST /builtins/{graph_name}+`

このエンドポイントは、組み込み関数を実行し、グラフに関連する統計値を返します。

==== リクエスト本文:

このエンドポイントは、グラフ上で実行される関数を指定するリクエスト本文のデータペイロードを想定しています。実行されている関数によって、リクエスト本文内で異なるフィールドが必要となる場合もあります。

このエンドポイントでサポートされている関数とそれに対応するデータペイロード形式を次に示します。

* `stat_vertex_attr`
 ** 指定された頂点タイプの `int` 、 `uint` 、 `float` 、 `double` 属性の最小値、最大値、平均値、およびブール属性の `true` と `false` のカウントを返します。
 ** データペイロードのフィールド:
  *** `"function": "stat_vertex_attr"`: これは、実行する関数が ``stat_vertex_attr`` であることを指定します。
  *** `"type"`: レポートする属性値を持つ頂点タイプ。必須フィールド。値 `*` (ワイルドカード)も受け付けます。この場合、すべての頂点タイプが含まれます。
* `stat_edge_attr`
 ** 指定されたエッジタイプの `int` 、 `uint` 、 `float` 、 `double` 属性の最小値、最大値、平均値、およびブール属性の `true` と `false` のカウントを返します。
 ** データペイロードのフィールド:
  *** `"function": stat_edge_attr`
  *** `"type"`: レポートする属性値を持つエッジタイプ。必須フィールド。値 `*` も受け付けます。この場合すべてのエッジタイプが含まれます。
  *** `"from_type"`: オプション。レポートするエッジのソース頂点タイプ。
  *** `"to_type"`: オプション。レポートするエッジのターゲット頂点タイプ。
* `stat_vertex_number`
 ** 指定された頂点タイプの頂点の数を返します。
 ** データペイロードのフィールド:
  *** `"function"`:  `"stat_vertex_number"`
  *** `"type"`: 必須フィールド。カウントする頂点の頂点タイプ。値 `*` (ワイルドカード)も受け付けます。この場合、すべての頂点タイプが含まれます。
* `stat_edge_number`
 ** 指定されたエッジタイプのエッジの数を返します
 ** データペイロードのフィールド:
  *** `"function": "stat_edge_number"`
  *** `"type"`: 必須フィールド。カウントするエッジのエッジタイプ。値 `*` も受け付けます。この場合すべてのエッジタイプが含まれます。
  *** `"from_type"`: オプション。レポートするエッジのソース頂点タイプ。
  *** `"to_type"`: オプション。レポートするエッジのターゲット頂点タイプ。

==== リクエストサンプル:

以下は、 `socialNet` での `stat_vertex_attr` の実行リクエストの例とその出力です。頂点タイプ `"Person"` には `uint` 属性 `"age"` があります。

[source,bash]
----
curl -X POST "http://localhost:9000/builtins/socialNet" \
-d  '{"function":"stat_vertex_attr","type":"Person"}' | jq .

{
  "version": {
      "api": "v2",
      "schema": 0
   },
  "error": false,
  "message": "",
  "results": [
    {
      "vertexName": "Person",
      "attributeStat": [
        {
          "vattrName": "age",
          "MAX": 64,
          "MIN": 15,
          "AVG": 36.5
        }
      ]
    }
  ]
}
----

これは、 `socialNet` での `stat_edge_attr` の実行リクエストの例とその出力です。エッジタイプ `"Liked"` は float属性 `"strength"` を持ちます。

[source,bash]
----
curl -X POST "http://localhost:9000/builtins/socialNet" \
-d  '{"function":"stat_edge_attr","type":"Liked", "from_type":"*", "to_type":"*"}' | jq .

{
  "version": {
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "e_type": "Liked",
      "attributes": {
        "weight": {
          "MAX": 2.5,
          "MIN": 1,
          "AVG": 1.375
        }
      }
    }
  ]
}
----

これは、 `stat_vertex_number` の実行リクエストの例とその出力です。

[source,bash]
----
curl -X POST "http://localhost:9000/builtins/socialNet" \
-d  '{"function":"stat_vertex_number","type":"*"}' | jq .

{
  "version": {
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "v_type": "User",
      "count": 4
    },
    {
      "v_type": "Page",
      "count": 4
    },
    {
      "v_type": "Product",
      "count": 7
    },
    {
      "v_type": "DescWord",
      "count": 7
    },
    {
      "v_type": "NameUser",
      "count": 9
    },
    {
      "v_type": "VidUser",
      "count": 4
    },
    {
      "v_type": "Video",
      "count": 5
    },
    {
      "v_type": "AttributeTag",
      "count": 4
    }
  ]
}
----

==== パラメーター:

パラメーターはありません。

=== グラフデータスキーマのメタデータの表示

`GET /gsqlserver/gsql/schema`

頂点タイプ、エッジタイプ、またはグラフスキーマ全体に関するスキーマの詳細を返します。これはポート14240に送信されるGSQLサーバー要求であり、認証資格情報を供給する必要があります。

==== リクエストサンプル:

[source,bash]
----
$ curl -u tigergraph:tigergraph \
"localhost:14240/gsqlserver/gsql/schema?graph=workNet&type=company"

{
  "error": false,
  "message": "",
  "results": {
    "Config": {
      "STATS": "OUTDEGREE_BY_EDGETYPE",
      "PRIMARY_ID_AS_ATTRIBUTE": false
    },
    "Attributes": [
      {
        "AttributeType": {
          "Name": "STRING"
        },
        "IsPartOfCompositeKey": false,
        "PrimaryIdAsAttribute": false,
        "AttributeName": "id",
        "HasIndex": false,
        "IsPrimaryKey": false
      },
      {
        "AttributeType": {
          "Name": "STRING"
        },
        "IsPartOfCompositeKey": false,
        "PrimaryIdAsAttribute": false,
        "AttributeName": "country",
        "HasIndex": false,
        "IsPrimaryKey": false
      }
    ],
    "PrimaryId": {
      "AttributeType": {
        "Name": "STRING"
      },
      "IsPartOfCompositeKey": false,
      "PrimaryIdAsAttribute": false,
      "AttributeName": "clientId",
      "HasIndex": false,
      "IsPrimaryKey": false
    },
    "Name": "company"
  }
}
----

__**頂点スキーマオブジェクトの**__ **フィールド:**

* *`Name`*: 頂点タイプ名。入力パラメーター"type"と:同じです。
* *`PrimaryId`*: プライマリーIDに関する詳細。
* *`Attributes`*: 各属性の詳細。順番にリストされます。
* *`Config`*: 頂点タイプのグローバルプロパティーに関する詳細。

__**エッジスキーマオブジェクトの**__ **フィールド:**

* *`Name`*: エッジタイプ名。入力パラメーター"type"と:同じです。
* *`FromVertexTypeName`*: ソース頂点タイプ名。
* *`ToVertexTypeName`*: ターゲット頂点タイプ名。
* *`Attributes`*: 各属性の詳細。順番にリストされます。
* *`IsDirected`*: エッジが方向付けられているか。
* *`Config`*: エッジタイプのグローバルプロパティーに関するさらなる詳細。

__**グラフスキーマオブジェクトの**__ **フィールド:**

* *`GraphName`*: グラフ名。入力パラメーター"graph"と:同じです。
* *`VertexTypes`*: __頂点スキーマオブジェクト__ の配列。特定の頂点タイプが指定されている場合、それぞれの頂点スキーマオブジェクトはJSON出力になります。
* *`EdgeTypes`*: __エッジスキーマオブジェクト__ の配列。特定のエッジタイプが指定されている場合、それぞれのエッジスキーマオブジェクトはJSON出力になります。

[source,bash]
----
{
  "error": false,
  "message": "",
  "results": {
    "GraphName": "workNet",
    "VertexTypes": [
      {
        "Config": {...},
        "Attributes": [...],
        "PrimaryId": {...},
        "Name": "person"},
      {
        "Config": {...},
        "Attributes": [...],
        "PrimaryId": {...},
        "Name": "company"}
    ],
    "EdgeTypes": [
      {
        "IsDirected": false,
        "ToVertexTypeName": "company",
        "Config": {},
        "Attributes": [...],
        "FromVertexTypeName": "person",
        "Name": "worksFor"
      }
    ]
  }
}
----

====パラメーター:

|===
| 名称 | 必須 | 説明

| `graph`
| はい
| スキーマを取得するグラフ名。

| `type`
| いいえ
| 詳細を取得する頂点またはエッジタイプ。指定しない場合、エンドポイントは、グラフ全体のスキーマの詳細を含む __グラフスキーマオブジェクト__ を返します。
|===

=== データのグラフへのアップサート

`+POST /graph/{graph_name}+`

このエンドポイントは、頂点および/またはエッジをグラフにアップサートします。アップサートとは、頂点またはエッジが存在しない場合に挿入を行ない、存在する場合は更新することを意味します。

==== アトミックアップサートトランザクション

`+POST /graph/{graph_name}+` エンドポイントは、デフォルトではアトミックではありません。リクエスト処理中に問題が発生した場合、リクエストデータはデータベースによって部分的にコンシュームされる可能性があります。

クエリ文字列パラメーター `atomic_post` をリクエストのURLに加え、その値をtrueに設定することで、リクエストをアトミックトランザクションにすることができます。これは、リクエストに含まれるデータベースへの更新が「オール・オア・ナッシング」になることを意味します。つまり、すべての変更が成功するか、どれも成功しないということです。つまり、すべての変更が成功するか、どれも成功しないということです。

たとえば、次の2つの頂点をアップサートするリクエストがあるとします。

[source,text]
----
curl --data-binary @vertices.json http://localhost:9000/graph/social
----

And the content of `vertices.json` is:

[source,text]
----
{
 "vertices": {
    "person": {
      "Velma": {
        "age": {
           "value": 30
         }
      },
      "Kelly": {
        "age": {
           "value": 22
         }
      }
    }
  }
}
----

上記のリクエストにおいて、マシンの障害によって頂点 `Kelly` のアップサートに失敗しているにもかかわらず、頂点 `Velma` はデータベースにアップサートされている可能性があります。

`atomic_post` パラメーターをリクエストURLに追加し、その値をtrueに設定すると、リクエストはアトミックになり、リクエスト本文のいずれかの部分がアップサートに失敗した場合には、何もアップサートされなくなります。

[source,bash]
----
# これはアトミックリクエストです
curl --data-binary @vertices.json http://localhost:9000/graph/social?automic_post=true
----

==== パラメーター
[width="100%",cols="23%,9%,68%",options="header",]
|===
|名称 |必須 |説明
|`ack` |いいえ |このパラメーターの値は、 `"all"` または `"none"` のいずれかです。
`"all"` : リクエストは、すべてのGPEインスタンスがPOST を認識後、
結果を返します。
`"none"` : リクエストは、RESTPPがPOSTを処理した直後に結果を返します。
デフォルト値はfalseです。

|`new_vertex_only` |いいえ | `new_vertex_only` がtrueの場合、リクエストは新しい頂点
を挿入しますが、既存の頂点の更新は行ないません。
デフォルト値はfalseです。

|`vertex_must_exist` |いいえ | `vertex_must_exist` がtrueの場合、エッジの `FROM` 頂点と `TO` 頂点の両方がすでに存在する場合に、
リクエストは *エッジ* を挿入します。
値がfalseの場合、リクエストは常に新しいエッジを挿入し、属性のデフォルト値で必要な頂点を作ります。
このパラメーターは頂点に影響を与えないことにご注意ください。
デフォルト値はfalseです。

|`update_vertex_only` |いいえ | `update_vertex_only` がtrueの場合、リクエストは既存の頂点を更新しますが、新しい頂点の挿入は行ないません。

|`atomic_post` |いいえ | `atomic_post` がtrueの場合、リクエストはアトミックトランザクションになります。これによって、すべての更新が成功するか、すべての更新が成功しないかのどちらかになります。
デフォルト値はfalseです。|
|===

返されるのは、受け付けられた頂点とエッジの数です。APIは、アップサートされる頂点とエッジの記述にJSON形式を使用します。
JSONコードは、テキストファイルに保存することも、コマンドラインで直接指定することもできます。
`POST` データペイロードには最大サイズがあります。これについては、xref:API:intro.adoc#_size_and_time_limits[**サイズ制限**]セクションを参照してください。
頂点セットまたはエッジセットを記述するためのJSON形式については、以下をご覧ください。

==== リクエスト本文

ペイロードデータは、以下に示すスキーマに従ってJSON形式で記述される必要があります。

.リクエスト本文スキーマ
====
[source,bash]
----
{
    "vertices": {
       "<vertex_type>": {
          "<vertex_id>": {
             "<attribute>": {
                "value": <value>,
                "op": <opcode>
             }
          }
       }
    },
    "edges": {
       "<source_vertex_type>": {
          "<source_vertex_id>": {
             "<edge_type>": {
                "<target_vertex_type>": {
                   "<target_vertex_id>": {
                      "<attribute>": {
                         "value": <value>,
                         "op": <opcode>
                      }
                   }
                }
             }
          }
       }
    }
}
----
山かっこ(`<>`)内のフィールドは、実際の値に置き換えるプレースホルダー名または値です。
`<Vertex_type>` などの山かっこ内のキーを繰り返して、アイテムのリストを作成することができます。
山かっこで囲まれていないキーは、そのまま使用する必要のあるテキストです。
ネストされた階層は、頂点がタイプごとにグループ化されていることを意味しています。
一方、エッジは、最初にソース頂点タイプ、次に頂点ID、その次にエッジタイプによってグループ化されます。
====

以下に示す最初の例は、`age` という属性を持つ2つの `User` 頂点を示しています。

.アップサートのデータ例1: 2つのユーザー頂点
[source,json]
----
{
  "vertices": {
    "User": {
      "id6": {
        "age": {
           "value": 30
         }
      },
      "id1": {
        "age": {
           "value": 22
         }
      }
    }
  }
}
----

次の例は、1つの頂点 `User` から始まります。
`Id6` には属性が含まれていないため、すでに存在している場合は、変わりません。
まだ存在していない場合、リクエストはデフォルトの属性値でID `id6` の頂点を作成します。
次に、`id1` から `id6` への `Liked` エッジと、`id6` から `id1` への `Liked_By` エッジの2つが作成されます。

.アップサートのデータ例2: add_id6.json
[source,json]
----
{
 "vertices": {
    "User": {
      "id6": {
      }
    }
  },
  "edges": {
    "User":{
      "id1": {
        "Liked": {
          "User": {
            "id6" : {
              "weight" : {
                "value": 5.0
              }
            }
          }
        }
      },
      "id6": {
        "Liked_By": {
          "User": {
            "id1" : {
              "weight" : {
                "value": 1.0
              }
            }
          }
        }
      }
    }
  }
}
----

「はじめに」セクションの指示に従って、xref:API:intro.adoc#_formatting_data_in_json[高度なデータタイプのフォーマット]を行ないます。

たとえば、次のペイロードは、 `LIST` タイプの属性 `coordinates` と `MAP` タイプの属性 `measurements` を持つ2つの `User` 頂点をアップサートするために使用されます。

[source,bash]
----
{
 "vertices": {
    "User": {
      "id4": {
        "coordinates": {
           "value": [51.3345, -7.2233]
         },
        "measurements": {
           "value": {
             "keyList": ["chest", "waist", "hip"]
             "valueList": [35, 30, 35]
           }
         }
      },
      "id5": {
        "coordinates": {
           "value": [31.3245, -17.3292]
         },
        "measurements": {
           "value": {
             "keyList": ["chest", "waist", "hip"]
             "valueList": [39, 35, 41]
           }
         }
      }
    }
  }
}
----

==== オペレーションコード

属性値には、データの更新または挿入を行なうための非常に高度なスキームを指示する、オペレーション(op)コードが付随しているものがあります。

|===
| タイプ | op | 意味

| 1
| `"ignore_if_exists"` または `"~"`
| 頂点/エッジが存在しない場合は、ペイロード値を使用して属性を初期化します。ただし、頂点/エッジがすでに存在する場合は、属性を変更しません。

| 2
| `"add"` または `"+"`
| ペイロード値を既存の値に加えます。

| 3
| `"and"` または `"&"`
| ペイロード値と既存の値の論理積へと更新します。

| 4
| `"or"` または `"\|"`
| ペイロード値と既存の値の論理和へと更新します。

| 5
| `"max"` または `">"`
| ペイロード値と既存の値のうち、より高い値へと更新します。

| 6
| `"min"` または `"<"`
| ペイロード値と既存の値のうち、より低い値へと更新します。
|===

ペイロードに属性が指定されていない場合、頂点/エッジがすでに存在していれば、属性は変更されません。頂点/エッジが存在していなければ、新しい頂点/エッジが作成され、そのデータ型のデフォルト値が入ります。デフォルト値は、 `int/uint` の場合は0、 `float/double` の場合は0.0、stringの場合は `""`(空の文字列)です。

==== 無効なデータ型の場合、リクエストは拒否されます。

RESTPPサーバーは、値を更新する前にリクエストを検証します。以下はスキーマ違反の例です。こうした場合、リクエスト全体が失敗し、グラフは変更されません。

* 頂点のアップサート
 ** 無効な頂点タイプ
 ** 無効な属性データタイプ
* エッジのアップサート
 ** 無効なソース頂点タイプ
 ** 無効なエッジタイプ
 ** 無効なターゲット頂点タイプ
 ** 無効な属性データタイプ

無効な属性名が指定された場合、無視されます。

==== 応答の出力

返されるのは、受け付けられた頂点とエッジの数です。また、 `new_vertex_only` がtrueの場合、応答にはさらに2つのフィールドが含まれます。

* `skipped_vertices` : グラフにすでに存在する入力データの頂点の数。
* `vertices_already_exist` : スキップされた入力頂点のIDとタイプ。

`vertex_must_exist` がtrueの場合、応答にはさらに2つのフィールドが含まれます。

* `skipped_edges` : エンドポイントの頂点が欠落していることが原因で拒否された入力データのエッジの数。
* `miss_vertices` : 欠落していたエンドポイント頂点のIDとタイプ。

サンプルファイル `add_id6.json` (**リクエスト本文** セクションをご覧ください)では、1つの `User` 頂点を `id = "id6"` でアップサートします。また、1つの `Liked` エッジを `"id1"` から `"id6"` へ 、 `Liked_By` エッジを `"id6"` から `"id1"` へアップサートします。

==== 例

次の例では、`add_id6.json` に保存されているペイロードデータを使ってアップサートリクエストを送信します。

[source,bash]
----
$ curl -X POST --data-binary @add_id6.json \
"http://localhost:9000/graph"

{"accepted_vertices":1,"accepted_edges":2}
----

`Vertex_must_exist` パラメーターの値を `true` にすると、エンドポイントは、エンドポイントの頂点が存在するエッジのみを挿入します。これには、同じリクエストに挿入されている頂点が含まれます。
したがって、 `add_id6.json` の内容を空のグラフに挿入すると、エッジは拒否されます。

[source,bash]
----
$ curl -X POST --data-binary @add_id6.json \
"http://localhost:9000/graph?vertex_must_exist=true"

{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "accepted_vertices": 1,
      "accepted_edges": 0,
      "skipped_edges": 2,
      "edge_vertices_not_exist": [
        {
          "v_type": "User",
          "v_id": "id1"
        }
      ]
    }
  ],
  "code": "REST-0003"
}
----

== 頂点

[NOTE]
====
1つのシステム内の複数のグラフをサポートするために、グラフデータのRESTエンドポイントURLにはオプションのグラフ名が含まれています。
====

=== 頂点の挿入

頂点またはエッジを挿入するには、xref:API:built-in-endpoints.adoc#_upsert_data_to_graph[データのグラフへのアップサート]エンドポイントを使用します

=== 頂点のリスト化

`+GET /graph/{graph_name}/vertices/{vertex_type}+`

このエンドポイントは、グラフ内のタイプ __`vertex_type`__ を持つすべての頂点を返します。

==== リクエストサンプル:

[source,javascript]
----
curl -X GET "http://localhost:9000/graph/socialNet/vertices/User"

{
  "version": {
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "v_id": "id1",
      "v_type": "User",
      "attributes": {}
    },
    {
      "v_id": "id2",
      "v_type": "User",
      "attributes": {}
    }
    // ... all vertices in graph socialNet of type User
  ]
}
----

==== パラメーター

|===
| 名称 | 必須 | 説明

| `count_only`
| いいえ
| ブール値を取ります。値がtrueの場合、`results` フィールドにはいくつの頂点が選択されたかのカウントのみが含まれます。デフォルトは `false` です。

| `select`
| いいえ
| 返すように選択された頂点の属性。パラメーターは、コンマで区切られた値の文字列のリストを受け取り、指定された属性のみを返します。

| `filter`
| いいえ
| 返された頂点をフィルタリングするために使用する条件。このパラメーターは、条件のリスト(コンマで区切られた値の文字列)を取ります。フィルタリング条件が指定されている場合、エンドポイントは条件を満たす頂点のみを返します。このパラメーターでは、 `=` 、 `!=` 、 `>` 、 `>=` 、 `<` 、 `+<=+` の6つの比較演算子がサポートされています。演算子の右側の値が文字列リテラルの場合は、二重引用符で囲む必要があります。

| `limit`
| いいえ
| 返すエッジの合計数の最大値を指定する整数値。

| `sort`
| いいえ
| 結果を並べ替えるために使用する属性。パラメーターは、コンマで区切られた値の文字列のリストを受け取り、リストで指定された属性に基づいて、返されたエッジをすべて並べ替えます。属性の前に "-" を追加して、降順で並べ替えを行ないます。

| `timeout`
| いいえ
| クエリがタイムアウトするまでの秒数を指定する整数。パラメーターが `0` に設定されているか、何も指定されていない場合、システム全体のエンドポイントのタイムアウト設定が適用されます。
|===

=== 頂点の取得

`+GET /graph/{graph_name}/vertices/{vertex_type}/{vertex_id}+`

このエンドポイントは、頂点IDによって単一の頂点を返します。

==== リクエストサンプル:

[source,javascript]
----
curl -X GET "http://localhost:9000/graph/socialNet/vertices/User/id1"

{
  "version": {
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "v_id": "id1",
      "v_type": "User",
      "attributes": {}
    }
  ]
}
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `select`
| いいえ
| 返すように選択された頂点の属性。パラメーターは、コンマで区切られた値の文字列のリストを受け取り、指定された属性のみを返します。

| `timeout`
| いいえ
| クエリがタイムアウトするまでの秒数を指定する整数。パラメーターが0に設定されているか、何も指定されていない場合、システム全体のエンドポイントのタイムアウト設定が適用されます。
|===

=== 頂点の削除

`+DELETE /graph/{graph_name}/vertices/{vertex_type}+`

このエンドポイントは、頂点タイプに基づいて頂点を削除します。この削除操作はカスケード削除です。頂点が削除されると、それに接続されているエッジもすべて自動的に削除されます。

==== リクエストサンプル:

応答オブジェクトは、削除された頂点の数を示す `"deleted_vertices"` フィールドを含みます。

[source,bash]
----
curl -X DELETE "http://localhost:9000/graph/socialNet/vertices/User"

{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": {
    "v_type": "person",
    "deleted_vertices": 3
  }
}
----

==== パラメーター
[width="100%",cols="15%,10%,75%",options="header",]
|===
|名称 |必須 |説明
|`permanent` |いいえ |ブール値を取ります。値がtrueの場合、
グラフがドロップされるか、グラフの保存がクリアされない限り、
削除された頂点IDを元に戻すことはできません。

|`filter` |いいえ |削除する頂点をフィルタリングする条件。
このパラメーターは、条件のリスト(コンマで区切られた値の文字列)
を取ります。 フィルタリング条件が指定されている場合、
エンドポイントは条件を満たす頂点のみを削除します。
このパラメーターでは、 `=` 、 `!=` 、 `>` 、 `>=` 、 `<` 、 `+<=+` の
6つの比較演算子がサポートされています。
演算子の右側の値が文字列リテラルの場合は、二重引用符で囲む必要があります。

|`limit`|いいえ| 削除する頂点の合計数を指定する
整数値。

|`sort` |いいえ |頂点を並べ替えるために使用する属性。削除操作では、
`sort` は常に `limit` とともに用いる必要があります。
エンドポイントは、指定された順序で、指定された制限内の頂点の数を削除します。
パラメーターは属性のリストを取り、エンドポイントはリストが指定する属性に
基づいて頂点をすべて順番に並べ替えます。
属性の前に "-" を追加して、その属性の降順で並べ替えを
行います。

|`timeout` |いいえ | クエリーがタイムアウトするまでの秒数を指定する整数。
パラメーターが0に設定されているか、何も指定されていない場合、
システム全体のエンドポイントのタイムアウト設定が適用されます。
|===


=== タイプに基づいた頂点の削除

`+DELETE /graph/{graph_name}/delete_by_type/vertices/{vertex_type}+`

このエンドポイントは、グラフ内にある指定された頂点タイプの頂点をすべて削除します。

==== リクエストサンプル:

[source,bash]
----
curl -X DELETE "http://localhost:9000/graph/poc_graph/delete_by_type/vertices/person"
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `permanent`
| いいえ
| ブール値を取ります。値がtrueの場合、グラフがドロップされるか、グラフの保存がクリアされない限り、削除された頂点IDを元に戻すことはできません。

| `ack`
| いいえ
| パラメーターが"none"に設定されているとき、削除操作はGPEから確認の応答を取得する必要はありません。"all"(デフォルト)に設定されている場合、すべてのGPEから確認の応答を取得する必要があります。
|===

=== 頂点の削除

`+DELETE /graph/{graph_name}/vertices/{vertex_type}/{vertex_id}+`

==== リクエストサンプル:

[source,bash]
----
curl -X DELETE "http://localhost:9000/graph/socialNet/vertices/User/id1"

{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": {
    "v_type": "User",
    "deleted_vertices": 1
  }
}
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `timeout`
| no
| クエリーがタイムアウトするまでの秒数を指定する整数。パラメーターが0に設定されているか、何も指定されていない場合、システム全体のエンドポイントのタイムアウト設定が適用されます。
|===

== エッジ

=== エッジの挿入

頂点またはエッジを挿入するには、xref:API:built-in-endpoints.adoc#_upsert_data_to_graph[データのグラフへのアップサート]エンドポイントを使用します。

=== 頂点のエッジのリスト化

`+GET /graph/{graph_name}/edges/{source_vertex_type}/{source_vertex_id}+`

このエンドポイントは、グラフ内の指定された頂点IDにつながるエッジをすべて返します。

==== リクエストサンプル:

[source,bash]
----
curl -X GET "http://localhost:9000/graph/socialNet/edges/VidUser/0?limit=2

{
  "version": {
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "e_type": "User_Video",
      "directed": false,
      "from_id": "0",
      "from_type": "VidUser",
      "to_id": "2",
      "to_type": "Video",
      "attributes": {
        "rating": 5.2,
        "date_time": 0
      }
    },
    {
      "e_type": "User_Video",
      "directed": false,
      "from_id": "0",
      "from_type": "VidUser",
      "to_id": "0",
      "to_type": "Video",
      "attributes": {
        "rating": 6.8,
        "date_time": 0
      }
    }
  ]
}
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `count_only`
| いいえ
| ブール値を取ります。値がtrueの場合、`results` フィールドにはいくつのエッジが選択されたかのカウントのみが含まれます。デフォルトは `false` です。

| `select`
| いいえ
| 返すように選択されたエッジの属性。このパラメーターは、リスト(コンマで区切られた値の文字列)を取ります。`select` が指定された場合、返されるエッジには指定された属性のみが表示されます。

| `filter`
| いいえ
| 返されるエッジをフィルタリングするために使用する条件。このパラメーターは、条件のリスト(コンマで区切られた値の文字列)を取ります。フィルタリング条件が指定されている場合、エンドポイントは条件を満たすエッジのみを返します。このパラメーターでは、 `=` 、 `!=` 、 `>` 、 `>=` 、 `<` 、 `+<=+` の6つの比較演算子がサポートされています。演算子の右側の値が文字列リテラルの場合は、二重引用符で囲む必要があります。

| `limit`
| いいえ
| 返すエッジの合計数の最大値を指定する整数値。

| `sort`
| いいえ
| 結果を並べ替えるために使用する属性。パラメーターは、コンマで区切られた値の文字列のリストを受け取り、リストで指定された属性に基づいて、返されたエッジをすべて並べ替えます。属性の前に `"-"` を追加して、降順で並べ替えを行ないます。

| `timeout`
| いいえ
| クエリがタイムアウトするまでの秒数を指定する整数。パラメーターが `0` に設定されているか、何も指定されていない場合、システム全体のエンドポイントのタイムアウト設定が適用されます。
|===

=== 頂点のエッジのエッジタイプに基づくリスト化

`+GET /graph/{graph_name}/edges/{source_vertex_type}/{source_vertex_id}/{edge_type}+`

このエンドポイントは、グラフ内の指定された頂点IDにつながる、指定されたタイプのエッジをすべてリスト化します。

==== リクエストサンプル:

[source,bash]
----
curl -X GET "http://localhost:9000/graph/socialNet/edges/VidUser/0/User_Video?limit=2

{
  "version": {
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "e_type": "User_Video",
      "directed": false,
      "from_id": "0",
      "from_type": "VidUser",
      "to_id": "2",
      "to_type": "Video",
      "attributes": {
        "rating": 5.2,
        "date_time": 0
      }
    },
    {
      "e_type": "User_Video",
      "directed": false,
      "from_id": "0",
      "from_type": "VidUser",
      "to_id": "0",
      "to_type": "Video",
      "attributes": {
        "rating": 6.8,
        "date_time": 0
      }
    }
  ]
}
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `count_only`
| いいえ
| ブール値を取ります。値がtrueの場合、`results` フィールドにはいくつのエッジが選択されたかのカウントのみが含まれます。デフォルトは `false` です。

| `select`
| いいえ
| 返すように選択されたエッジの属性。このパラメーターは、リスト(コンマで区切られた値の文字列)を取ります。`select` が指定された場合、返されるエッジには指定された属性のみが表示されます。

| `filter`
| いいえ
| 返されるエッジをフィルタリングするために使用する条件。このパラメーターは、条件のリスト(コンマで区切られた値の文字列)を取ります。フィルタリング条件が指定されている場合、エンドポイントは条件を満たすエッジのみを返します。このパラメーターでは、 `=` 、 `!=` 、 `>` 、 `>=` 、 `<` 、 `+<=+` の6つの比較演算子がサポートされています。演算子の右側の値が文字列リテラルの場合は、二重引用符で囲む必要があります。

| `limit`
| いいえ
| 返すエッジの合計数の最大値を指定する整数値。

| `sort`
| いいえ
| 結果を並べ替えるために使用する属性。パラメーターは、コンマで区切られた値の文字列のリストを受け取り、リストで指定された属性に基づいて、返されたエッジをすべて並べ替えます。属性の前に `"-"` を追加して、降順で並べ替えを行ないます。

| `timeout`
| いいえ
| クエリがタイムアウトするまでの秒数を指定する整数。パラメーターが `0` に設定されているか、何も指定されていない場合、システム全体のエンドポイントのタイムアウト設定が適用されます。
|===

=== 頂点のエッジのエッジタイプ、ターゲットタイプに基づくリスト化

[source,bash]
----
GET /graph/{graph_name}/edges/{source_vertex_type}/{source_vertex_id}/{edge_type}/{target_vertex_type}
----

このエンドポイントは、指定された頂点に接続されているエッジをエッジタイプとターゲット頂点タイプ別にリスト化します。

[NOTE]
====
URLの `edge_type` に `"_"` を使用して、任意のエッジタイプを許可します。
====

==== リクエストサンプル:

[source,php]
----
curl -X GET "http://localhost:9000/graph/socialNet/edges/VidUser/0/User_Video/Video?limit=2

{
  "version": {
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "e_type": "User_Video",
      "directed": false,
      "from_id": "0",
      "from_type": "VidUser",
      "to_id": "2",
      "to_type": "Video",
      "attributes": {
        "rating": 5.2,
        "date_time": 0
      }
    },
    {
      "e_type": "User_Video",
      "directed": false,
      "from_id": "0",
      "from_type": "VidUser",
      "to_id": "0",
      "to_type": "Video",
      "attributes": {
        "rating": 6.8,
        "date_time": 0
      }
    }
  ]
}
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `count_only`
| いいえ
| ブール値を取ります。値がtrueの場合、`results` フィールドにはいくつのエッジが選択されたかのカウントのみが含まれます。デフォルトは `false` です。

| `not_wildcard`
| いいえ
| エンドポイントのURLで指定された `+"_"+` がワイルドカードであるかどうかを示すブール値。パラメーターがtrueの場合、 `+"_"+` は文字通り解釈され、エッジタイプ名がアンダーバー("_")に等しいエッジのみを選択します。

| `select`
| いいえ
| 返すように選択されたエッジの属性。このパラメーターは、リスト(コンマで区切られた値の文字列)を取ります。`select` が指定された場合、返されるエッジには指定された属性のみが表示されます。

| `filter`
| いいえ
| 返されるエッジをフィルタリングするために使用する条件。このパラメーターは、条件のリスト(コンマで区切られた値の文字列)を取ります。フィルタリング条件が指定されている場合、エンドポイントは条件を満たすエッジのみを返します。このパラメーターでは、 `=` 、 `!=` 、 `>` 、 `>=` 、 `<` 、 `+<=+` の6つの比較演算子がサポートされています。演算子の右側の値が文字列リテラルの場合は、二重引用符で囲む必要があります。

| `limit`
| いいえ
| 返すエッジの合計数の最大値を指定する整数値。

| `sort`
| いいえ
| 結果を並べ替えるために使用する属性。パラメーターは、コンマで区切られた値の文字列のリストを受け取り、リストで指定された属性に基づいて、返されたエッジをすべて並べ替えます。属性の前に `"-"` を追加して、降順で並べ替えを行ないます。

| `timeout`
| いいえ
| クエリがタイムアウトするまでの秒数を指定する整数。パラメーターが `0` に設定されているか、何も指定されていない場合、システム全体のエンドポイントのタイムアウト設定が適用されます。
|===

=== ソース、ターゲット、およびエッジタイプごとのエッジの取得

[source,bash]
----
GET /graph/{graph_name}/edges/{source_vertex_type}/{source_vertex_id}/{edge_type}/{target_vertex_type}/{target_vertex_id}
----

このエンドポイントは、ソース頂点とターゲット頂点の間の指定されたタイプのエッジを返します。

==== リクエストサンプル:

[source,bash]
----
curl -X GET "http://localhost:9000/graph/socialNet/edges/VidUser/0/User_Video/Video/2"

{
  "version": {
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "e_type": "User_Video",
      "directed": false,
      "from_id": "0",
      "from_type": "VidUser",
      "to_id": "2",
      "to_type": "Video",
      "attributes": {
        "rating": 5.2,
        "date_time": 0
      }
    }
   ]
 }
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `select`
| いいえ
| 返すように選択されたエッジの属性。このパラメーターは、リスト(コンマで区切られた値の文字列)を取ります。`select` が指定された場合、返されるエッジには指定された属性のみが表示されます。

| `timeout`
| いいえ
| クエリがタイムアウトするまでの秒数を指定する整数。パラメーターが `0` に設定されているか、何も指定されていない場合、システム全体のエンドポイントのタイムアウト設定が適用されます。
|===

=== エッジの削除

[source,bash]
----
DELETE /graph/{graph_name}/edges/{source_vertex_type}/{source_vertex_id}/{edge_type}/{target_vertex_type}/{target_vertex_id}
----

ソース頂点タイプとID、ターゲット頂点タイプとID、およびエッジタイプに基づいてエッジを削除します。

==== リクエストサンプル

[source,bash]
----
$ curl -X DELETE "https://crunch.i.tgcloud.io:9000/graph/CrunchBasePre_2013/edges/person/p:23601/work_for_company/company/c:14478"

# 応答
{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "e_type": "work_for_company",
      "deleted_edges": 1
    }
  ]
}
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `timeout`
| いいえ
| クエリがタイムアウトするまでの秒数を指定する整数。パラメーターが0に設定されているか、何も指定されていない場合、システム全体のエンドポイントのタイムアウト設定が適用されます。
|===

== クエリ

=== クエリのメタデータの取得

`GET /gsqlserver/gsql/queryinfo`

クエリのメタデータの詳細を返します。特に、入力パラメーターと出力の `PRINT` ステートメント構文をリスト化します。 **このエンドポイントは14240ポートに存在し、リクエストはGSQLサーバーに送られます。** そのため、リクエストで認証資格情報を指定する必要があります。

==== リクエストサンプル:

[source,gsql]
----
$ curl -u tigergraph:tigergraph -X GET \
"http://localhost:14240/gsqlserver/gsql/queryinfo?graph=workNet&query=to_vertex_setTest"

{
  "output": [
    {
      "v": "vertex"
    },
    {
      "@@v2": "SetAccum<vertex>"
    },
    {
      "S2": [
        {
          "v_id": "int",
          "attributes": {
            "interestList": "INT_LIST",
            "skillSet": "INT_SET",
            "skillList": "INT_LIST",
            "locationId": "STRING",
            "interestSet": "INT_SET",
            "id": "STRING"
          },
          "v_type": "person"
        },
        {
          "v_id": "int",
          "attributes": {
            "country": "STRING",
            "id": "STRING"
          },
          "v_type": "company"
        }
      ]
    },
    {
      "SDIFF.size()": "int"
    }
  ],
  "input": {
    "uid": "string",
    "uids": "set<string>",
    "vtype": "string"
  },
  "queryname": "to_vertex_setTest",
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "DEVELOPER_EDITION",
    "api": "V2"
  }
}
----

JSON応答オブジェクトには、以下の3つのフィールドがあります。

* **`queryname`**: クエリーの名前。クエリー入力パラメーターと:同じです。
* **`input`**: 入力パラメーター名とデータ型の順序付けされていないリスト。
* **`output`**: クエリーの出力と同じ構造に従うJSONオブジェクト。キーと値のペアのうちの、キーはクエリー出力に表示される名前であり、値は出力のデータタイプです。

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `graph`
| はい
| グラフ名。

| `query`
| はい
| クエリー名。
|===

=== インストールしたクエリーの実行(`GET`)

`+GET /query/{graph_name}/{query_name}+`

新しいTigerGraphのクエリーがインストールされるたびに、動的エンドポイントが生成されます。この新しいエンドポイントによって、HTTPリクエストを通じて新しいTigerGraphのクエリーを実行することができます。URLまたはデータペイロードでのパラメーターの指定が可能です。`GET` リクエストの場合、パラメーターはクエリー文字列を通じて渡される必要があります。

==== パラメーター

|===
| 名称 | 必須 | 説明

| `read_committed`
| いいえ
| クエリに https://en.wikipedia.org/wiki/Isolation_(database_systems)#Read_committed[read-committedの分離レベル]を使用するかどうかを指定するブール値。read-committedの分離レベルの場合、読み取り時点でコミット済みになっているデータを読み込みます。デフォルトではオフになっています。
|===

==== クエリのパラメーターの受け渡し

`GET` リクエストを使用してインストールされたクエリーを実行する場合、クエリーパラメーターはxref:API:intro.adoc#_query_string_parameters[URLのクエリー文字列を通じて渡されます]。
[width="100%",cols="28%,36%,36%",options="header",]
|===
|パラメータータイプ |クエリー文字列形式 |例
|プリミティブのセットまたはバッグ |同じパラメーター名に複数の値を割り当てます。
|整数のセット `p1` : `**p1=1&p1=5&p1=10**`

|`VERTEX<type>` |頂点IDを使用します: `parameterName = verbex_id` | 
パラメーター名が `vp` でIDがperson2の頂点: `**vp=person2**`

|`VERTEX`(タイプの事前指定なし) |2つのクエリー文字列パラメーターを使用**:**
`parameterName=vertex_id\'\'parameterName.type=vertex_type`
|パラメーター名が `va`、タイプが `person` 、IDが `person1` の頂点:
`va=person1&va.type=person`

|`VERTEX<type>` のセットまたはバッグ |同じ `セット` または `バッグ` のパラメーター名に
複数の頂点IDを割り当てます。 |タイプ personの頂点の `vp` という
設定パラメーター:`vp=person3&vp=person4`

|`VERTEX` のセットまたはバッグ(タイプの事前指定なし) |`セット` または `バッグ` は
配列として扱われる必要があります。各インデックスの頂点要素には、
頂点IDとタイプの指定が必要です。 |頂点の `vp` という設定パラメーター:
vertices:`vp[0]=person1&vp[0].type=person&vp[1]=11&vp[1].type=post`
|===

==== レプリカの指定

TigerGraph HAクラスターを持っている場合、HTTPヘッダー `GSQL-REPLICA` を使用することで、クエリーを指定して、特定のレプリカ上で実行することができます。ヘッダーの値は、クラスターのレプリケーション係数の範囲内の整数である必要があります。ヘッダーに無効な値を指定すると、リクエストはエラーを返します。

==== スレッド制限の指定

RESTPPを通じてクエリを実行する場合、HTTPヘッダー `GSQL-THREAD-LIMIT` を利用して、クエリがそれぞれのノードで使用できるスレッド数の制限を指定できます。クエリで使用されるスレッドの数とは、クエリで使用されるvCPUの数を意味します。デフォルトでは、クエリはマシンで使用可能なすべてのスレッドを使用します。

たとえば、それぞれ8つのvCPUを備えた3つのノードのクラスターの場合、クエリは、デフォルトではクラスター内のノードで使用可能な8つのスレッドすべてを使用します。リクエストヘッダーにスレッド制限を指定することで、制限内の数のスレッドのみを使用するようにクエリをコントロールできます。

==== リクエストサンプル:

`social` というグラフで `hello` というクエリを実行し、クエリパラメーターのタイプが `VERTEX<person>` で、IDが `"Tom"` である場合。

.HTTPリクエストを通じたクエリの実行

[source,bash]
----
curl -X GET "http://localhost:9000/query/social/hello?p=Tom"

# 4スレッド以下を使用するようクエリを制限
curl -x GET -H "GSQL-THREAD-LIMIT: 4" "http://localhost:9000/query/social/hello?p=Tom"

# 最初のレプリカで実行するクエリを指定
curl -X GET -H "GSQL-REPLICA: 2" "http://localhost:9000/query/social/hello?p=Tom"

# プライマリークラスターで実行するクエリを指定
curl -X GET -H "GSQL-REPLICA: 1" "http://localhost:9000/query/social/hello?p=Tom"
----



[#_run_an_installed_query_post]
=== インストールしたクエリーの実行(`GET`)

`+POST /query/{graph_name}/{query_name}+`

`POST` リクエストを通じて、クエリを実行することもできます。この場合、JSONでクエリパラメーターを渡すことができます。これは、クエリが複雑なパラメーターをとる場合に特に有効です。

==== パラメーター

|===
| 名称 | 必須 | 説明

| `read_committed`
| いいえ
| クエリに https://en.wikipedia.org/wiki/Isolation_(database_systems)#Read_committed[read-committedの分離レベル]を使用するかどうかを指定するブール値。read-committedの分離レベルの場合、読み取り時点でコミット済みになっているデータを読み込みます。デフォルトではオフになっています。
|===

==== クエリーのパラメーターの受け渡し

`POST` リクエストを使用してインストールされたクエリーを実行する際、クエリーパラメーターはリクエスト本文を通して、xref:API:intro.adoc#_formatting_data_in_json[JSON形式でエンコード]した形で渡されます。JSONペイロードのフォーマットルールは、xref:3.2@gsql-ref:querying:query-operations.adoc#_parameter_json_object[JSONを使用した `RUNQUERY` コマンドでのパラメーターの受け渡し]の場合と同様です。

[width="99%",cols="28%,36%,36%",options="header",]
|===
|パラメータータイプ |シンタックス |例
|`DATETIME` |`"YYYY-MM-DD HH-MM-SS"` 形式の文字列を使用。
|`"2019-02-19 19:19:19"`

|プリミティブのセットまたはバッグ |プリミティブ値を含むJSO配列を使用。 
|`["a", "list", "of", "args"]`

|`VERTEX<type>` |頂点IDにフィールド `"id"` を含み、
頂点のタイプにフィールド `"type"` を含むJSONオブジェクトを使用。
|`{"id": "person1",\'\'"type": "person"}`

|`VERTEX` (タイプの事前指定なし) |頂点IDにフィールド `"id"` を含むJSONオブジェクトを
使用。 |`{"id": "person1"}`

|`VERTEX<type>` のセットまたはバッグ |JSON `VERTEX<type>` オブジェクトのリストを含む
JSON配列を使用。 |`[{"id": "person1"}, {"id": "person2"}]`

|タイプ指定れていない頂点のセットまたはバッグ | JSON `VERTEX` のリストを
含むJSON配列を使用。
|`[{"id": "person1",\'\'"type": "person"},{"id": "person2",\'\'"type": "person"}]`
|===

==== レプリカの指定

TigerGraph HAクラスターを持っている場合、HTTPヘッダー `GSQL-REPLICA` を使用することで、クエリーを指定して、特定のレプリカ上で実行することができます。ヘッダーの値は、クラスターのレプリケーション係数の範囲内の整数である必要があります。ヘッダーに無効な値を指定すると、リクエストはエラーを返します。

==== スレッド制限の指定

RESTPPを通じてクエリを実行する場合、HTTPヘッダー `GSQL-THREAD-LIMIT` を利用して、クエリがそれぞれのノードで使用できるスレッド数の制限を指定できます。クエリで使用されるスレッドの数とは、クエリで使用されるvCPUの数を意味します。デフォルトでは、クエリはマシンで使用可能なすべてのスレッドを使用します。

たとえば、それぞれ8つのvCPUを備えた3つのノードのクラスターの場合、クエリは、デフォルトではクラスター内のノードで使用可能な8つのスレッドすべてを使用します。リクエストヘッダーにスレッド制限を指定することで、制限内の数のスレッドのみを使用するようにクエリをコントロールできます。

==== リクエストサンプル

このリクエストサンプルのクエリーは、`VERTEX<person>` タイプのパラメーターを取ります。

[source,bash]
----
curl -X POST -d '{"p":{"id":"Tom","type":"person"}}' \
"http://localhost:9000/query/social/hello"

# クエリが最初のレプリカで実行されるように指定
curl -X POST -d -H "GSQL-REPLICA: 2" '{"p":{"id":"Tom","type":"person"}}' \
"http://localhost:9000/query/social/hello"

# クエリがプライマリークラスターで実行されるように指定
curl -X POST -d -H "GSQL-REPLICA: 1" '{"p":{"id":"Tom","type":"person"}}' \
"http://localhost:9000/query/social/hello"

# クエリの実行を指定
curl -X POST -d -H "GSQL-THREAD-LIMIT: 4" '{"p":{"id":"Tom","type":"person"}}' \
"http://localhost:9000/query/social/hello"
----

[NOTE]
====
インストールされたクエリーは、xref:gsql-ref:querying:query-operations.adoc#_detached_mode_async_option[デタッチモード]で実行できます。そのためには、 ``GSQL-ASYNC``ヘッダーを使用し、値を `true` に設定します。デタッチモードで実行されるクエリーのxref:built-in-endpoints.adoc#_check_query_status_detached_mode[結果]およびlink:built-in-endpoints.adoc#_check_query_status_detached_mode[ステータス] は、クエリーIDで取得できます。クエリーがデタッチモードで実行されるとすぐに返されます。
====

=== インタープリテッドクエリの実行

`POST /gsqlserver/interpreted_query`

このエンドポイントは、インタープリターモードでGSQLクエリーを実行します。クエリ本文はデータペイロードで、クエリのパラメーターはURLのクエリ文字列として供給する必要があります。**このエンドポイントはGSQLサーバーのポート14240ポートに存在します。**

このリクエストは、RESTPPサーバー(ポート9000)ではなくGSQLサーバー(ポート14240)に直接送られるため、ユーザー名とパスワードをヘッダーで指定する必要があります。Curlを使用している場合は、以下に示す通り、 `-u` オプションを使用することができます。

==== リクエスト本文:

このエンドポイントのリクエスト本文は、 `INTERPRET QUERY` ステートメント全体である必要があります。

==== パラメーターの受け渡し:

このエンドポイントを通じてインタープリテッドクエリーを実行する場合、クエリーパラメーターはxref:intro.adoc#_query_string_parameters[URLクエリー文字列を通じての受け渡し]が行なわれる必要があります。

==== リクエストサンプル:

[source,javascript]
----
curl --fail -u <my_username>:<my_password> -X POST \
"http://localhost:14240/gsqlserver/interpreted_query?a=10" \
-d 'INTERPRET QUERY (INT a) FOR GRAPH gsql_demo {
    PRINT a;
 }'
----

=== 実行中クエリのリスト化

`+GET /showprocesslist/{graph_name}+`

このエンドポイントは、グラフの実行中のクエリの統計情報(クエリのリクエストID、開始時刻、有効期限、RESTエンドポイントのURL)をレポートします。

==== リクエストサンプル:

[source,bash]
----
curl -X GET "http://localhost:9000/showprocesslist/poc_graph" | jq .

{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "requestid": "65538.RESTPP_1_1.1558386411523.N",
      "startTime": "2019-05-20 14:06:51.523",
      "expirationTime": "2019-05-20 14:15:11.523",
      "url": "/sleepgpe?milliseconds=100001"
    },
    {
      "requestid": "196609.RESTPP_1_1.1558386401478.N",
      "startTime": "2019-05-20 14:06:41.478",
      "expirationTime": "2019-05-20 14:15:01.478",
      "url": "/sleepgpe?milliseconds=100000"
    }
  ],
  "code": "REST-0000"
}
----

==== パラメーター:

パラメーターはありません。

=== クエリの中止

`+GET /abortquery/{graph_name}+`

このエンドポイントは、IDによって指定されたクエリ、またはグラフのエンドポイントURLによって指定されたエンドポイントのすべてのクエリを安全に中止します。

==== リクエストサンプル:

[source,graphql]
----
curl -X GET "localhost:9000/abortquery/poc_graph?requestid=16842763.RESTPP_1_1.1561401340785.N&requestid=16973833.RESTPP_1_1.1561401288421.N"

{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "aborted_queries": [
        {
          "requestid": "16842763.RESTPP_1_1.1561401340785.N",
          "url": "/sleepgpe?milliseconds=110000"
        },
        {
          "requestid": "16973833.RESTPP_1_1.1561401288421.N",
          "url": "/sleepgpe?milliseconds=100000"
        }
      ]
    }
  ],
  "code": "REST-0000"
}
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `requestid`
| いいえ
| 中止するクエリのID。ひとつのクエリIDまたは文字列 `"all"` が使用できます。`requestid` を `"all"` にすると、実行中の全てのクエリが中止されます。

| `url`
| いいえ
| 実行中のクエリを中止するエンドポイント。エンドポイントのURLのベースを指定する必要がありますが、ワイルドカードを使用してさまざまなパラメーターを許可することができます。たとえば、エンドポイント `/sleepgpe` の実行中のすべてのクエリを中止するには、 `url =/sleepgpe*` と指定します。
|===

=== クエリのステータスの確認(デタッチモード)

`GET /query_status`

このエンドポイントを使用すると、xref:3.2@gsql-ref:querying:query-operations.adoc#_detached_mode_async_option[デタッチモード]で実行されたクエリのステータスを確認できます。

==== リクエストサンプル:

[source,bash]
----
$ curl -s -X GET "http://localhost:9000/query_status?graph_name=poc_graph&requestid=4.RESTPP_1_1.1599672031541.N"

{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [{
    "requestid": "4.RESTPP_1_1.1599672031541.N",
    "startTime": "2020-09-09 10:20:31.541",
    "expirationTime": "2020-09-09 10:20:47.541",
    "url": "/query/ldbc_snb/countIndirectFriends?pid=21990232555889",
    "elapsedTime": 19,
    "status": "success"
  }]
}
----

|===
|**フィールド** | **説明**

| `url`
| 指定したクエリのURL。

| `status`
| 指定したクエリのステータス。可能な値は、 `“success”` 、 `“timeout”` 、 `“aborted”` 、 `“running”` です。

| `startTime`
| 指定されたクエリの開始時刻のタイムスタンプ。

| `requestid`
| 指定されたクエリのステータスJSONオブジェクトに関連付けられたクエリID。

| `expirationTime`
| 指定されたクエリがタイムアウトしたときのタイムスタンプ。デフォルトのタイムアウト制限は16秒で、xref:intro.adoc#_gsql_query_timeout[`GSQL-TIMEOUT`]ヘッダーを使って設定可能です。

| `elapsedTime`
| 指定されたクエリの経過時間(ミリ秒単位)。完了したクエリの場合、値はリクエスト実行の合計時間を示します。進行中のクエリの場合、これまでにかかった時間を示します。
|===

指定されたクエリID(`requestid`)に無効なものが含まれている場合、返されるJSONには、 `unknown_requestid` フィールドが含まれ、無効なクエリIDがすべて示されます。クエリIDが不明としてマークされた場合は、クエリが存在しないか、デタッチモードで実行されていないことを意味します。

==== パラメーター
[width="100%",cols="22%,78%",options="header",]
|===
|**フィールド** | **説明**
|`url` |指定したクエリのURL。

|`status` |指定したクエリのステータス。可能な値は、
`“success”` 、 `“timeout”` 、 `“aborted”` 、 `“running”` です。

|`startTime` |指定されたクエリの開始時刻のタイムスタンプ。

|`requestid` |指定されたクエリのステータス
JSONオブジェクトに関連付けられたクエリID。

|`expirationTime` |指定されたクエリがタイムアウトしたときのタイムスタンプ。
指定されたクエリがタイムアウトしたときのタイムスタンプ。デフォルトのタイムアウト制限は16秒で、
https://docs.tigergraph.com/v/3.2/dev/restpp-api/intro#gsql-query-timeout[`GSQL-TIMEOUT`] ヘッダーを
使って設定可能です。

|`elapsedTime` |指定されたクエリーの経過時間(ミリ秒単位)。
完了したクエリーの場合、値はリクエスト実行の合計時間を
示します。進行中のクエリーの場合、これまでにかかった時間を
示します。
|===

=== クエリの結果の確認(デタッチモード)

`GET /query_result`

このエンドポイントを使用すると、デタッチモードで実行されたクエリの終了後にその結果の確認ができます。クエリがまだ実行中の場合、エンドポイントはエラーを返し、「クエリ<requestid>の結果を取得できません」というメッセージが示されます。  結果を確認する前に、クエリが終了していることを確認してください。

==== リクエストサンプル:

[source,gsql]
----
$ curl -s -X GET curl -s -X GET "http://localhost:9000/query_result?requestid=196611.RESTPP_1_1.1630601692834.N"

{
  "error": false,
  "message": "",
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 0
  },
  "results": [{"vSet": [{
    "v_id": "21990232555889",
    "attributes": {"vSet.@friendCount": 13677},
    "v_type": "Person"
  }]}]
}
----

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `requestid`
| はい
| クエリーIDの文字列。
|===

== パス検索アルゴリズム

TigerGraphプラットフォームは、 `/shortestpath` と `/allpaths` の2つの組み込みエンドポイントを備えており、ソース頂点のセットとターゲット頂点のセットを接続する最短パスまたはすべての重み付けされていないパスを返します。以下の表は、2つのパス検索エンドポイントの特徴をまとめたものです。

=== パス検索の入力パラメーターと出力フォーマット

各RESTエンドポイントは、JSON形式の入力パラメーターのペイロードを読み取ります。これらのパラメーターには、パス上に存在する可能性のある頂点とエッジ、頂点とエッジの属性に関する追加の条件、およびパスの最大長を指定します。

==== ソース頂点およびターゲット頂点

各エンドポイントには、**ソース**キーと**ターゲット**パラメーターが必要です。ソースパラメーターとターゲットパラメーターは、単一の頂点を記述します。頂点オブジェクトの形式は次のとおりです。`{"type" : "<vertex_type_name>", "id" : "<vertex_id>"}.` ソースパラメーターとターゲットパラメーターは、頂点オブジェクトのリストを含むJSON配列です。

**フィルター** +
ペイロードには、パス内の頂点またはエッジを制限するために、フィルタリング条件を含めることもできます。個々のフィルターは、1つの頂点タイプまたはエッジタイプの条件を指定するJSONオブジェクトです。フィルターオブジェクトには、1つまたは2つのキー-値のペアがあります。 `{"type": "<vertex_or_edge_type>", "condition": "<attribute_condition>"}`

* `"type":` フィルターをかける頂点タイプまたはエッジタイプ
* `"condition"` (オプション): 指定された頂点タイプまたはエッジタイプの1つの属性のブール式。複合式を作成するために、"AND"および"OR"が使用できます。

フィルター配列の例:

[source,markup]
----
[{"type": "bought", "condition": "price < \"100\" and quality == \"good\""},
 {"type": "sold",   "condition": "price > \"100\"  or quality != \"good\""}]
----

*`vertexFilters`* および *`edgeFilters`* のすべてのフィルタリング条件が `"OR"` で繋がれていることに注意してください。つまり、頂点(またはエッジ)がいずれかのフィルタリング条件を満たしている場合、その頂点(またはエッジ)は、結果のパスに含まれます。

==== 出力

JSON出力は、頂点のリストとエッジのリストです。各頂点と各エッジは、すべての属性とともに完全にリスト化されます。 頂点とエッジはパス順に並んでいません。

=== 最短パスの検索

`+POST /shortestpath/{graph_name}+`

このエンドポイントは、ソース頂点(単数または複数)、ターゲット頂点(単数または複数)を取り、ソースとターゲットの間の最短パスを返します。ソースが複数の頂点である場合、結果のパスは複数の頂点うちの1つから始まります。ターゲットが複数の頂点である場合、結果のパスは複数の頂点うちの1つに行き着きます。

==== リクエスト本文:

このエンドポイントは、ソースやターゲットの頂点(単数または複数)を記述するリクエスト本文を想定しています。以下の表で、リクエスト本文のすべてのフィールドについて説明しています。

|===
| キー | タイプ | 説明

| `source`
| 頂点オブジェクト
| 各パスは、この頂点から開始する必要があります。`sources` を使用する場合 `sources` は使用されません。

| `sources`
| 複数の頂点の配列
| 各パスは、これらの頂点のうちの1つから開始する必要があります。`sources` を使用する場合 `source` は使用されません。

| `target`
| 頂点オブジェクト
| 各パスは、この頂点で集結する必要があります。`target` を使用する場合 `targets` は使用されません。

| `targets`
| 複数の頂点の配列
| 各パスは、これらの頂点のうちの1つで集結する必要があります。`targets` を使用する場合 `target` は使用されません。

| `vertexFilters`
| フィルターの配列
| (オプション)頂点が指定されたフィルターのいずれかを満たすパスのみを選ぶようフィルターを掛けます。

| `edgeFilters`
| フィルターの配列
| (オプション)エッジが指定されたフィルターのいずれかを満たすパスのみを選ぶようフィルターを掛けます。上記のフィルターの詳細を参照してください。
|===

==== リクエストサンプル:

[source,bash]
----
curl -s -X POST "http://localhost:9000/shortestpath/movieNet" \
-d '{
  "sources":[{"type":"VidUser","id":"2"}],
  "targets":[{"type":"VidUser","id":"0"}, {"type":"VidUser","id":"3"}],
  "edgeFilters":[{"type":"User_Video","condition":"rating > 5 and date_time > 1000"}],
  "maxLength":4
}'

# 結果は、頂点JSONオブジェクトとエッジJSONオブジェクトの配列であり、
# 検索されたすべての頂点とエッジのサブグラフを記述します。
{
  "version": { "edition": "developer", "api": "v2", "schema": 0 },
  "error": false,
  "message": "Cannot get 'vertex_filters' filters, use empty filter.",
  "results": [
    {
      "vertices": [
        { "v_id": "3","v_type": "VidUser","attributes": { "name": "Dale" }},
        { "v_id": "0","v_type": "Video","attributes": { "name": "Solo", "year", 2018 }},
        { "v_id": "0","v_type": "VidUser","attributes": { "name": "Angel" }},
      ],
      "edges": [
        {
          "e_type": "User_Video", "from_id": "0", "from_type": "Video",
          "to_id": "0", "to_type": "VidUser", "directed": false,
          "attributes": { "rating": 6.8, "date_time": 15000 }
        },
        {
          "e_type": "User_Video", "from_id": "0", "from_type": "Video",
          "to_id": "3", "to_type": "VidUser",  "directed": false,
          "attributes": { "rating": 6.6, "date_time": 16000 }
        }
      ]
    }
  ]
}
----

==== パラメーター:

|===
| キー | 必須 | 説明

| `maxLength`
| いいえ
| 最短パスの最大長を指定する整数。デフォルト値は6です。

| `allShortestPaths`
| いいえ
| *true* に設定すると、エンドポイントはソースとターゲット間の最短パスをすべて返します。デフォルトは *false* です。この場合、エンドポイントは1つのパスのみを返します。
|===

=== すべてのパスの検索

`+POST /allpaths/{graph_name}+`

このエンドポイントは、ソース頂点(単数または複数)とターゲット頂点(単数または複数)の間のパスをすべて検索します。

==== リクエスト本文:

このエンドポイントは、ソースやターゲットの頂点(単数または複数)を記述するリクエスト本文を想定しています。以下の表で、リクエスト本文のすべてのフィールドについて説明しています。

|===
| キー | タイプ | 説明

| `source`
| 頂点オブジェクト
| 各パスは、この頂点から開始する必要があります。`sources` を使用する場合 `sources` は使用されません。

| `sources`
| 複数の頂点の配列
| 各パスは、これらの頂点のうちの1つから開始する必要があります。`sources` を使用する場合 `source` は使用されません。

| `target`
| 頂点オブジェクト
| 各パスは、この頂点で集結する必要があります。`target` を使用する場合 `targets` は使用されません。

| `targets`
| 複数の頂点の配列
| 各パスは、これらの頂点のうちの1つで集結する必要があります。`targets` を使用する場合 `target` は使用されません。

| `vertexFilters`
| フィルターの配列
| (オプション)頂点が指定されたフィルターのいずれかを満たすパスのみを選ぶようフィルターを掛けます。

| `edgeFilters`
| フィルターの配列
| (オプション)エッジが指定されたフィルターのいずれかを満たすパスのみを選ぶようフィルターを掛けます。上記のフィルターの詳細を参照してください。
|===

==== パラメーター:

|===
| 名称 | 必須 | 説明

| `maxLength`
| はい
| 最大パス長。
|===

[WARNING]
====
このエンドポイントの現在の仕様には、ループを伴うパスが含まれます。1つのループを何度も回る可能性があるため、maxLengthの値には、適切と思われる、できる限り小さな値を選択することが重要です。  グラフにループがない場合でも、maxLengthを小さくすることにより、クエリをより高速に実行できます。
====

==== リクエストサンプル:

次の例では、ソース頂点の集まり{Video 0}とターゲット頂点の集まり{AttributeTag "action"}の間の最大長3までのすべてのパスをリクエストしています。パスには、 `year >= 1984` の"Video"頂点のみを含めることができます。結果には次の3つのパスが含まれます。 +
AttrributeTag "action"  --  Video 0 +
AttrributeTag "action"  --  Video 3 -- VidUser 4 -- Video 0 +
AttrributeTag "action"  --  Video 2 -- VidUser 0 -- Video 0

[source,bash]
----
curl -s -X POST "http://localhost:9000/allpaths/movieNet" \
-d '{
  "sources":[{"type":"Video","id":"0"}],
  "targets":[{"type": "AttributeTag", "id":"action"}],
  "vertexFilters":[{"type":"Video", "condition":"year >= 1984"}],
  "maxLength": 3
}'

# 結果は、頂点JSONオブジェクトとエッジJSONオブジェクトの配列であり、
# 検索されたすべての頂点とエッジのサブグラフを示します。
{
  "version": { "edition": "developer", "api": "v2", "schema": 0 },
  "error": false,
  "message": "Cannot get 'edge_filters' filters, use empty filter.",
  "results": [
    {
      "vertices": [
        { "v_id": "action","v_type": "AttributeTag","attributes": {}},
        { "v_id": "3","v_type": "VidUser","attributes": { "name": "Dale" }},
        { "v_id": "0","v_type": "VidUser","attributes": { "name": "Angel" }},
        { "v_id": "0","v_type": "Video","attributes": { "name": "Solo", "year", 2018 }},
        { "v_id": "2","v_type": "Video","attributes": { "name": "Thor", "year", 2011 }},
        { "v_id": "4","v_type": "Video","attributes": { "name": "Ran", "year", 1985 }}
      ],
      "edges": [
        {
          "e_type": "Video_AttributeTag", "from_id": "0", "from_type": "Video",
          "to_id": "action", "to_type": "AttributeTag", "directed": false,
          "attributes": { "weight": 1, "date_time": 0 }
        },
        {
          "e_type": "Video_AttributeTag", "from_id": "4", "from_type": "Video",
          "to_id": "action", "to_type": "AttributeTag", "directed": false,
          "attributes": { "weight": 1, "date_time": 11000 }
        },
        {
          "e_type": "User_Video", "from_id": "3", "from_type": "VidUser",
          "to_id": "4", "to_type": "Video", "directed": false,
          "attributes": { "rating": 8.4, "date_time": 12000 }
        },
        {
          "e_type": "User_Video", "from_id": "3", "from_type": "VidUser",
          "to_id": "0", "to_type": "Video", "directed": false,
          "attributes": { "rating": 6.6, "date_time": 16000 }
        },
        {
          "e_type": "Video_AttributeTag", "from_id": "2", "from_type": "Video",
          "to_id": "action", "to_type": "AttributeTag", "directed": false,
          "attributes": { "weight": 1, "date_time": 0 }
        },
        {
          "e_type": "User_Video", "from_id": "2", "from_type": "VidUser",
          "to_id": "0", "to_type": "Video", "directed": false,
          "attributes": { "rating": 7.4, "date_time": 17000 }
        },
        {
          "e_type": "User_Video", "from_id": "0", "from_type": "Video",
          "to_id": "0", "to_type": "VidUser", "directed": false,
          "attributes": { "rating": 6.8, "date_time": 15000 }
        }
      ]
    }
  ]
}
----

パス検索の他のバージョンは、xref:graph-ml:intro:overview.adoc[GSQLグラフアルゴリズムライブラリー]でご覧ください。
