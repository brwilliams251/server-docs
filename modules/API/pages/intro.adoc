= はじめに
:pp: {plus}{plus}

TigerGraphのREST APIエンドポイントは、REST{pp}とGSQLサーバーに存在します。REST{pp} (またはRESTPP)は、TigerGraphのカスタマイズされた https://en.wikipedia.org/wiki/Representational_state_transfer[REST] サーバーです。APIは、URLでエンコードされたクエリ文字列パラメーター https://www.json.org/json-en.html[JSON]でエンコードされたリクエスト本文を受け入れ、JSONでエンコードされた応答を返します。このユーザーガイドでは、REST APIを使用する方法について説明します。この「はじめに」セクションでは、リクエストの送信、パラメーターの受け渡し、リクエスト本文のフォーマット方法について説明します。その後のセクションでは、各エンドポイントとその入力・出力について詳しく説明します。

リクエストを送るには、HTTPリクエストをREST{pp}サーバーまたはGSQLサーバーに送信します。 xref:troubleshooting:system-administration-faqs.adoc#_how_can_i_find_out_the_port_of_a_service [デフォルト]では、REST{pp}サーバーはポート9000で、GSQLサーバーはポート14240でリクエストをリッスンします。リクエストには次の5つを指定する必要があります。

* リクエストメソッド(`GET`、 `POST` 、 `PUT` 、または `DELETE`)
* エンドポイントアドレス
* URLエンコードの必須またはオプションのリクエストパラメーター
* `POST` リクエストの場合、特に指定がなければ、JSONエンコーディングのデータペイロード(つまり、リクエストの本文)
* リクエストヘッダーパラメーター(一部のケース)

GSQLサーバーに送信されるリクエストの場合、送信者は、リクエストが受け入れられるよう、TigerGraphユーザー資格情報を指定する必要があります。RESTPPサーバーで認証が有効になっている場合は、リクエストトークンもリクエストヘッダーに含める必要があります。

[NOTE]
====
テスト環境または開発環境では、リクエスターはREST{pp}と同じサーバー上にある可能性があります。この場合、サーバーIPは *localhost* です。
====

== クエリ文字列パラメーター

TigerGraphのAPIエンドポイントは、URLエンコードのパラメーターを受け入れます。これが文字列、数値、ブール値の場合は簡単ですが、一部のパラメーターはより複雑で、特定のフォーマットが必要となります。以下のリストは、クエリ実行時に複雑なタイプのパラメーター値をフォーマットする方法を示しています。

[width="100%",cols="<34%,<33%,<33%",options="header",]
|===
|パラメータータイプ |説明 |例
|プリミティブタイプの `+SET+` または `+BAG+` |同じパラメーター名に複数の値を割り
当てます。|`+p1+` という名前の `+SET<INT>+` パラメーターに、3つの整数が割り当て
られています。
 
*`+p1=1&p1=5&p1=10+`*

|定義されたタイプの `+VERTEX+` |頂点の主キーを使用します。|


`+vp+` という名前の `+VERTEX<person>+` パラメーターに、IDが `+"person2"+` の頂点を
割り当てています。:

*`+vp=person2+`*

|定義されたタイプなしの `+VERTEX+`
|`+<parameter_name>.<parameter_type> +` を使用して
パラメーターのタイプを指定し、頂点の主キーも指定します。 |


`+va+` という名前の `+VERTEX+` パラメーターに、 `+"person1"+` というIDの
`person` タイプの頂点が割り当てられています。

*`+va=person1&va.type=person+`*

|定義されたタイプの頂点の `+SET+` または `+BAG+`|プリミティブの `+SET+` 
または `+BAG+` と同様。それぞれのエレメントの値は頂点の主キーです。|`+vp+` 
という名前の `+SET<VERTEX<person>>+` パラメーターにIDが `+"person3"+` 
と `+"person4"+` の2つの頂点に割り当てられています

*`+vp=person3&vp=person4+`*

|定義されたタイプのない頂点の `+SET+` または `+BAG+`|`+SET+` または 
`+BAG+` は配列として扱う必要があり、インデックス `++`,`++` など、
要素の順序を指定します。
|`+vp+` という名前の `+SET<VERTEX>+` パラメーターに、IDが 
`+"person5"+` の `person` タイプの頂点とIDが `+11+` の 
`post` タイプの頂点が割り当てられます。

*`+vp[0]=person5&vp[0].type=person&vp[1]=11&vp[1].type=post+`*

|===

== `POST` リクエストの入力データ

エンドポイントが特別に、他のフォーマットのデータを受け入れない限り、`POST` リクエストの入力データはJSON形式でなければなりません。データを指定方法には、インラインまたは別ファイルの2つがあります。

=== **インラインデータ**

データは、改行なしの単一の文字列としてフォーマットする必要があります。curlを使用する場合、 `-d` __**__ オプションを使用し、その後にJSON文字列を続けます。

.インラインデータペイロードを使ったPOSTリクエストの構文

[source,bash]
----
curl -X POST -d 'json_string' "http://server_ip:9000/path_to_endpoint?request_parameters"
----



次の例では、 `POST / graph` エンドポイントを使用してIDが ``"id6"`` である1つのユーザータイプの頂点を `"socialNet"` というグラフに挿入しています。

.インライン入力データを使用した例

[source,bash]
----
curl -X POST -d '{"vertices":{"User":{"id6":{"id":{"value":"id6"}}}}}' "http://localhost:9000/graph/socialNet"
----



=== **データファイル**

多くの場合、そして特にデータが大きい場合は、入力データを別のファイルに入れる方が便利です。

curlには、次の例のように `--data-binary <path_to_file>` __**__ を使用します。

.データファイルペイロードを使ったPOSTリクエストの構文

[source,bash]
----
curl -X POST --data-binary <path_to_file> "http://server_ip:9000/path_to_endpoint?parameter1=<parameter1>"
----



=== JSONでのデータフォーマット

`INT、UINT、FLOAT、DOUBLE、STRING、BOOL、DATETIME` などのプリミティブ型のデータ、配列とオブジェクトは、標準の https://www.json.org/json-en.html[JSONデータ交換構文] に従います。このサブセクションでは、複雑なデータ型をフォーマットする方法について説明します。

[width="100%",cols="<34%,<33%,<33%",options="header",]
|===
|データタイプ |説明 |例
|プリミティブタイプの `+SET+`、 `+LIST+` または `+BAG+`|プリミティブ値の
JSON配列を使用します。 a|
プリミティブ値: `[1、2、3]`

|`+VERTEX+` |`+id+` フィールドを持つJSONオブジェクトを使用します。
+
値が頂点の主キーである
+
値が頂点のタイプである `+"type"+` フィールドを
+
持つJSONオブジェクトを使用します。 a|
IDが `+"Tom"+` の `+person+` タイプの頂点 :

`+{"id": "Tom", "type": "person"}+`

|`+MAP+` |キーである `+keyList+` と `+valueList+`の
2つのJSON配列を持ち、それぞれにマップのキーと値が含まれている
JSONオブジェクトを使用します。

valueList内のアイテムの順序は、
keyList内のアイテムの順序に対応させます。 a|
国々とその首都のマップ:

`+{"keyList": ["England", "Germany"],+`

`+"valueList": }+`

|ユーザー定義タイプ (UDT) |キーである `+keyList+` と `+valueList+`

 の2つのJSON配列を持つJSONオブジェクトを

使用します。 `+keyList+` の配列にはタプルのフィールド名が含まれ、
`+valueList+` 配列にはフィールドの値が含まれます。



valueListの値の順序は、keyListのアイテムの
順序に対応させます。 a|
タプルのスキーマの定義:

`+TYPEDEF TUPLE <name STRING, age INT> person+`　`+person+`
JSONの `person` タプルの記述:

`+{"keyList: ["name", "age"], "valueList": ["Sam", 24]}+`

|===

.例: UDT定義 

[source,gsql]
----
TYPEDEF TUPLE <field1 INT(1), field2 UINT, field3 STRING(10), field4 DOUBLE> myTuple
----


==== 複合キーを持つ頂点

頂点がN個の属性で構成される複合キーを持つ場合、`"id"` にはN個の値を指定する必要があります。 値は、キーと値のペアN個を持つJSONオブジェクトとして、またはスキーマ内の定義と同じ順序でN個の値が並ぶリストを持つJSON配列として表すことができます。

以下の例は、3つの属性 `id`、 `name` 、 `label` で構成される複合主キーを持つ頂点 `v` の2つの表し方を示しています。

[tabs]
====
オプション1::
+
--
.JSONオブジェクトとして複合キーを持つ頂点 v
[source,javascript]
----
{
  "v": {
    "id": {
      "id": 3,
      "name": "c",
      "label": 300
    },
    "type": "v3"
  }
}
----
--
オプション2::
+
--
.JSON配列として複合キーを持つ頂点 v
[source,javascript]
----
{
  "v": {
    "id": {
      "id": [3, "c", 300] // 配列の価値はスキーマで定義された順序
                          // と同じである必要があります
    },
    "type": "v3"
  }
}
----
--
====

==== 頂点の `SET` または `BAG`

JSONで頂点の `SET` または `BAG` を記述するには、 `SET` または `BAG` 配列にネストされた _vertexオブジェクト_ を持つJSON配列を使用します。

== 応答の出力

TigerGraphのRESTの応答はすべてJSON形式です。出力されるJSONオブジェクトには、 `"version"` 、 `"error"` 、 `"message"` 、 `"result"` の4つのフィールドがあります。

* `"version"` - このフィールドは、実行中のTigerGraphインスタンスのバージョンを示します。
* "``error"`` - リクエストの実行でエラーが発生したかどうかを示すブール値。エラーが発生した場合、 `" error"` フィールドが `true` になります。
* `"message"` - エラーが起こった場合のエラーメッセージ。リクエストが成功した場合、フィールドには空の文字列またはリクエストの結果を伝える簡単なメッセージが入ります。
* `"results"` - このフィールドは、リクエストの結果データを含みます。それぞれの組み込みエンドポイントの結果の詳細については、xref:built-in-endpoints.adoc[組み込みエンドポイント]セクションで説明しています。

[source,javascript]
----
// 応答例
{
  "version": {
    "api": "v2",
    "schema": 0
  },
  "error": false,
  "message": "",
  "results": [
    {
      "v_id": "id1",
      "v_type": "User",
      "attributes": {}
    }
  ]
}
----

[NOTE]
====
ターミナルでJSON出力をより分かりやすくするには、 https://stedolan.github.io/jq/[`jq`] コマンドまたはほとんどのLinuxインストールに組み込まれているPython jsonライブラリーを使用します。

[source,bash]
----
curl -X method "http://server_ip:9000/path_to_endpoint?request_parameters" | jq .
curl -X method "http://server_ip:9000/path_to_endpoint?request_parameters" | python -m json.tool
----

====

== サイズとタイムの制限

リクエストURLの最大長は、クエリー文字列を含めて8Kバイトです。パラメーターサイズが大きいリクエストの場合、インラインデータではなくデータペイロードファイルを使用する必要があります。

=== リクエストの本文サイズ

ペイロードファイルを含むリクエスト本文の最大サイズは、システムパラメーター `Nginx.ClientMaxBodySize` によって設定されます。デフォルト値は200 MBです。この制限を増やすには、次の `gadmin` コマンドを使用します。

[source,console]
----
gadmin config set Nginx.ClientMaxBodySize NNN
----

この設定の上限は1,024 MBです。データペイロードバッファーのサイズ制限を上げることにより、他の操作のためのメモリーが減少するため、この制限を増やす作業には注意が必要です。

=== GSQLクエリのタイムアウト

TigerGraphシステムのHTTPリクエストは、デフォルトでは16秒後にタイムアウトになります。特定のクエリーインスタンスのためにこの制限をカスタマイズするには、リクエストヘッダーでGSQL-TIMEOUTパラメーターを設定します。curlを使用してRESTPPリクエストを送信する場合、構文は以下のようになります。

[source,bash]
----
curl -X <GET/POST> -H "GSQL-TIMEOUT: <timeout value in ms>" '<request_URL>'
----

=== 応答サイズ

HTTPリクエストの応答サイズ制限を指定するには、以下のヘッダーを使用します。

[source,bash]
----
curl -X <GET/POST> -H "RESPONSE-LIMIT: <size limit in byte>" '<request_URL>'
----

応答サイズが設定された制限より大きい場合、クエリーの結果の代わりに、エラーメッセージが返されます。

[source,bash]
----
{
  "error": true,
  "message": "The query response size is 256MB, which exceeds limit 32MB.",
  "results": [],
  "code": "REST-4000"
}
----

== `curl` のオプション

このガイドのリクエスト例は、 https://curl.se/docs/manpage.html[`curl`] を使用して作成されています。以下で、コード例で使用されている `curl` のオプションについて説明します。

* `-d <data>`
 ** `POST` リクエストで指定されたデータをHTTPサーバーに送信します。ブラウザーのHTMLフォームに入力を行って送信ボタンを押したときと同様、curlはコンテンツタイプ `application/x-www-form-urlencoded` を使用してデータをサーバーに送ります。
 ** データを文字 `"@"` で開始する場合、残りはデータを読み取るためのファイルパスにする必要があります。コマンド `curl -d @foobar` は、`foobar` という名前のファイルからデータを読み取ります。
* `--data-binary <data>`
 ** 追加の処理をすることなく、指定されたとおりに `POST` リクエストでデータを送信します。
* `--fail`
 ** サーバーエラーのときにcurlがサイレントで(まったく出力がなく)失敗するようにします。
 ** これは主に、スクリプト等が失敗した試みをより適切に処理できるようにするために使われます。通常、HTTPサーバーがドキュメントの送信に失敗すると、そのことを示すHTMLドキュメントが返されます(大抵、理由などの情報も説明されています)。このフラグにより、curlはこれを出力しなくなり、エラー22が返されます。
* `-H <header>`
 ** サーバーにHTTPを送信するときにリクエストに含める、追加のヘッダー。これはいくつでも指定できます。
 ** TigerGraph APIは、ヘッダーによって、xref:API:intro.adoc#_size_and_time_limits[サイズとタイムの制限]、およびRESTPP xref:authentication.adoc#_rest_server_requests[認証]トークンを指定します。
* `-s`
 **サイレントモードまたはクワイエットモード。プログレスメーターやエラーメッセージを表示しません。リダイレクトしない限り、要求したデータの出力は行われ、場合によってはターミナル/標準出力にも出力します。
* `-u <user:password>`
 ** サーバー認証のために指定されたユーザー名とパスワードを送信します。
* `-X <request_method>`
 ** HTTPサーバーと通信するときに使用するカスタムリクエストメソッドを指定します。このオプションを使用しない場合、デフォルトでcurlは `GET` リクエストを行います。
